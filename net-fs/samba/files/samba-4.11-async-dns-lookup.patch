From ce0ba3f64766805992c7c93f28fb399301c9f23c Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 11:43:03 -0700
Subject: [PATCH 01/62] s3: lib: Cleanup - all the ipstr_XXX() functions are
 only used in namecache.c.

Move them there. Will remove from the global namespace next.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/lib/util_str.c     | 166 -------------------------------------
 source3/libsmb/namecache.c | 164 ++++++++++++++++++++++++++++++++++++
 2 files changed, 164 insertions(+), 166 deletions(-)

diff --git a/source3/lib/util_str.c b/source3/lib/util_str.c
index e660e295c33..e43f178af29 100644
--- a/source3/lib/util_str.c
+++ b/source3/lib/util_str.c
@@ -643,172 +643,6 @@ bool str_list_substitute(char **list, const char *pattern, const char *insert)
 	return true;
 }
 
-
-#define IPSTR_LIST_SEP	","
-#define IPSTR_LIST_CHAR	','
-
-/**
- * Add ip string representation to ipstr list. Used also
- * as part of @function ipstr_list_make
- *
- * @param ipstr_list pointer to string containing ip list;
- *        MUST BE already allocated and IS reallocated if necessary
- * @param ipstr_size pointer to current size of ipstr_list (might be changed
- *        as a result of reallocation)
- * @param ip IP address which is to be added to list
- * @return pointer to string appended with new ip and possibly
- *         reallocated to new length
- **/
-
-static char *ipstr_list_add(char **ipstr_list, const struct ip_service *service)
-{
-	char *new_ipstr = NULL;
-	char addr_buf[INET6_ADDRSTRLEN];
-	int ret;
-
-	/* arguments checking */
-	if (!ipstr_list || !service) {
-		return NULL;
-	}
-
-	print_sockaddr(addr_buf,
-			sizeof(addr_buf),
-			&service->ss);
-
-	/* attempt to convert ip to a string and append colon separator to it */
-	if (*ipstr_list) {
-		if (service->ss.ss_family == AF_INET) {
-			/* IPv4 */
-			ret = asprintf(&new_ipstr, "%s%s%s:%d",	*ipstr_list,
-				       IPSTR_LIST_SEP, addr_buf,
-				       service->port);
-		} else {
-			/* IPv6 */
-			ret = asprintf(&new_ipstr, "%s%s[%s]:%d", *ipstr_list,
-				       IPSTR_LIST_SEP, addr_buf,
-				       service->port);
-		}
-		SAFE_FREE(*ipstr_list);
-	} else {
-		if (service->ss.ss_family == AF_INET) {
-			/* IPv4 */
-			ret = asprintf(&new_ipstr, "%s:%d", addr_buf,
-				       service->port);
-		} else {
-			/* IPv6 */
-			ret = asprintf(&new_ipstr, "[%s]:%d", addr_buf,
-				       service->port);
-		}
-	}
-	if (ret == -1) {
-		return NULL;
-	}
-	*ipstr_list = new_ipstr;
-	return *ipstr_list;
-}
-
-/**
- * Allocate and initialise an ipstr list using ip adresses
- * passed as arguments.
- *
- * @param ipstr_list pointer to string meant to be allocated and set
- * @param ip_list array of ip addresses to place in the list
- * @param ip_count number of addresses stored in ip_list
- * @return pointer to allocated ip string
- **/
-
-char *ipstr_list_make(char **ipstr_list,
-			const struct ip_service *ip_list,
-			int ip_count)
-{
-	int i;
-
-	/* arguments checking */
-	if (!ip_list || !ipstr_list) {
-		return 0;
-	}
-
-	*ipstr_list = NULL;
-
-	/* process ip addresses given as arguments */
-	for (i = 0; i < ip_count; i++) {
-		*ipstr_list = ipstr_list_add(ipstr_list, &ip_list[i]);
-	}
-
-	return (*ipstr_list);
-}
-
-
-/**
- * Parse given ip string list into array of ip addresses
- * (as ip_service structures)
- *    e.g. [IPv6]:port,192.168.1.100:389,192.168.1.78, ...
- *
- * @param ipstr ip string list to be parsed
- * @param ip_list pointer to array of ip addresses which is
- *        allocated by this function and must be freed by caller
- * @return number of successfully parsed addresses
- **/
-
-int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
-{
-	TALLOC_CTX *frame;
-	char *token_str = NULL;
-	size_t count;
-	int i;
-
-	if (!ipstr_list || !ip_list)
-		return 0;
-
-	count = count_chars(ipstr_list, IPSTR_LIST_CHAR) + 1;
-	if ( (*ip_list = SMB_MALLOC_ARRAY(struct ip_service, count)) == NULL ) {
-		DEBUG(0,("ipstr_list_parse: malloc failed for %lu entries\n",
-					(unsigned long)count));
-		return 0;
-	}
-
-	frame = talloc_stackframe();
-	for ( i=0; next_token_talloc(frame, &ipstr_list, &token_str,
-				IPSTR_LIST_SEP) && i<count; i++ ) {
-		char *s = token_str;
-		char *p = strrchr(token_str, ':');
-
-		if (p) {
-			*p = 0;
-			(*ip_list)[i].port = atoi(p+1);
-		}
-
-		/* convert single token to ip address */
-		if (token_str[0] == '[') {
-			/* IPv6 address. */
-			s++;
-			p = strchr(token_str, ']');
-			if (!p) {
-				continue;
-			}
-			*p = '\0';
-		}
-		if (!interpret_string_addr(&(*ip_list)[i].ss,
-					s,
-					AI_NUMERICHOST)) {
-			continue;
-		}
-	}
-	TALLOC_FREE(frame);
-	return count;
-}
-
-/**
- * Safely free ip string list
- *
- * @param ipstr_list ip string list to be freed
- **/
-
-void ipstr_list_free(char* ipstr_list)
-{
-	SAFE_FREE(ipstr_list);
-}
-
 /* read a SMB_BIG_UINT from a string */
 uint64_t STR_TO_SMB_BIG_UINT(const char *nptr, const char **entptr)
 {
diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 082f256bc02..8fc65675db9 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -24,6 +24,170 @@
 #include "includes.h"
 #include "lib/gencache.h"
 
+#define IPSTR_LIST_SEP	","
+#define IPSTR_LIST_CHAR	','
+
+/**
+ * Add ip string representation to ipstr list. Used also
+ * as part of @function ipstr_list_make
+ *
+ * @param ipstr_list pointer to string containing ip list;
+ *        MUST BE already allocated and IS reallocated if necessary
+ * @param ipstr_size pointer to current size of ipstr_list (might be changed
+ *        as a result of reallocation)
+ * @param ip IP address which is to be added to list
+ * @return pointer to string appended with new ip and possibly
+ *         reallocated to new length
+ **/
+
+static char *ipstr_list_add(char **ipstr_list, const struct ip_service *service)
+{
+	char *new_ipstr = NULL;
+	char addr_buf[INET6_ADDRSTRLEN];
+	int ret;
+
+	/* arguments checking */
+	if (!ipstr_list || !service) {
+		return NULL;
+	}
+
+	print_sockaddr(addr_buf,
+			sizeof(addr_buf),
+			&service->ss);
+
+	/* attempt to convert ip to a string and append colon separator to it */
+	if (*ipstr_list) {
+		if (service->ss.ss_family == AF_INET) {
+			/* IPv4 */
+			ret = asprintf(&new_ipstr, "%s%s%s:%d",	*ipstr_list,
+				       IPSTR_LIST_SEP, addr_buf,
+				       service->port);
+		} else {
+			/* IPv6 */
+			ret = asprintf(&new_ipstr, "%s%s[%s]:%d", *ipstr_list,
+				       IPSTR_LIST_SEP, addr_buf,
+				       service->port);
+		}
+		SAFE_FREE(*ipstr_list);
+	} else {
+		if (service->ss.ss_family == AF_INET) {
+			/* IPv4 */
+			ret = asprintf(&new_ipstr, "%s:%d", addr_buf,
+				       service->port);
+		} else {
+			/* IPv6 */
+			ret = asprintf(&new_ipstr, "[%s]:%d", addr_buf,
+				       service->port);
+		}
+	}
+	if (ret == -1) {
+		return NULL;
+	}
+	*ipstr_list = new_ipstr;
+	return *ipstr_list;
+}
+
+/**
+ * Allocate and initialise an ipstr list using ip adresses
+ * passed as arguments.
+ *
+ * @param ipstr_list pointer to string meant to be allocated and set
+ * @param ip_list array of ip addresses to place in the list
+ * @param ip_count number of addresses stored in ip_list
+ * @return pointer to allocated ip string
+ **/
+
+char *ipstr_list_make(char **ipstr_list,
+			const struct ip_service *ip_list,
+			int ip_count)
+{
+	int i;
+
+	/* arguments checking */
+	if (!ip_list || !ipstr_list) {
+		return 0;
+	}
+
+	*ipstr_list = NULL;
+
+	/* process ip addresses given as arguments */
+	for (i = 0; i < ip_count; i++) {
+		*ipstr_list = ipstr_list_add(ipstr_list, &ip_list[i]);
+	}
+
+	return (*ipstr_list);
+}
+
+
+/**
+ * Parse given ip string list into array of ip addresses
+ * (as ip_service structures)
+ *    e.g. [IPv6]:port,192.168.1.100:389,192.168.1.78, ...
+ *
+ * @param ipstr ip string list to be parsed
+ * @param ip_list pointer to array of ip addresses which is
+ *        allocated by this function and must be freed by caller
+ * @return number of successfully parsed addresses
+ **/
+
+int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
+{
+	TALLOC_CTX *frame;
+	char *token_str = NULL;
+	size_t i, count;
+
+	if (!ipstr_list || !ip_list)
+		return 0;
+
+	count = count_chars(ipstr_list, IPSTR_LIST_CHAR) + 1;
+	if ( (*ip_list = SMB_MALLOC_ARRAY(struct ip_service, count)) == NULL ) {
+		DEBUG(0,("ipstr_list_parse: malloc failed for %lu entries\n",
+					(unsigned long)count));
+		return 0;
+	}
+
+	frame = talloc_stackframe();
+	for ( i=0; next_token_talloc(frame, &ipstr_list, &token_str,
+				IPSTR_LIST_SEP) && i<count; i++ ) {
+		char *s = token_str;
+		char *p = strrchr(token_str, ':');
+
+		if (p) {
+			*p = 0;
+			(*ip_list)[i].port = atoi(p+1);
+		}
+
+		/* convert single token to ip address */
+		if (token_str[0] == '[') {
+			/* IPv6 address. */
+			s++;
+			p = strchr(token_str, ']');
+			if (!p) {
+				continue;
+			}
+			*p = '\0';
+		}
+		if (!interpret_string_addr(&(*ip_list)[i].ss,
+					s,
+					AI_NUMERICHOST)) {
+			continue;
+		}
+	}
+	TALLOC_FREE(frame);
+	return count;
+}
+
+/**
+ * Safely free ip string list
+ *
+ * @param ipstr_list ip string list to be freed
+ **/
+
+void ipstr_list_free(char* ipstr_list)
+{
+	SAFE_FREE(ipstr_list);
+}
+
 #define NBTKEY_FMT  "NBT/%s#%02X"
 
 /**
-- 
2.20.1


From ccb983f3689d841939e835512cf896978f6859f3 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 11:48:30 -0700
Subject: [PATCH 02/62] s3: lib: Cleanup - nothing uses ipstr_list_free().
 Remove it.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/include/proto.h    |  1 -
 source3/libsmb/namecache.c | 11 -----------
 2 files changed, 12 deletions(-)

diff --git a/source3/include/proto.h b/source3/include/proto.h
index 0c0ffc4f3ff..75d6f30249e 100644
--- a/source3/include/proto.h
+++ b/source3/include/proto.h
@@ -627,7 +627,6 @@ char *ipstr_list_make(char **ipstr_list,
 			const struct ip_service *ip_list,
 			int ip_count);
 int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list);
-void ipstr_list_free(char* ipstr_list);
 uint64_t STR_TO_SMB_BIG_UINT(const char *nptr, const char **entptr);
 uint64_t conv_str_size(const char * str);
 int asprintf_strupper_m(char **strp, const char *fmt, ...)
diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 8fc65675db9..6a4bbc7216f 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -177,17 +177,6 @@ int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
 	return count;
 }
 
-/**
- * Safely free ip string list
- *
- * @param ipstr_list ip string list to be freed
- **/
-
-void ipstr_list_free(char* ipstr_list)
-{
-	SAFE_FREE(ipstr_list);
-}
-
 #define NBTKEY_FMT  "NBT/%s#%02X"
 
 /**
-- 
2.20.1


From 859f2b701626728b6984bcee043daa6dbfaeba8d Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 11:58:45 -0700
Subject: [PATCH 03/62] s3: lib: Cleanup - make ipstr_list_make() and
 ipstr_list_parse() private to the only user.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/include/proto.h    | 4 ----
 source3/libsmb/namecache.c | 4 ++--
 2 files changed, 2 insertions(+), 6 deletions(-)

diff --git a/source3/include/proto.h b/source3/include/proto.h
index 75d6f30249e..8562317553c 100644
--- a/source3/include/proto.h
+++ b/source3/include/proto.h
@@ -623,10 +623,6 @@ bool str_list_sub_basic( char **list, const char *smb_name,
 			 const char *domain_name );
 bool str_list_substitute(char **list, const char *pattern, const char *insert);
 
-char *ipstr_list_make(char **ipstr_list,
-			const struct ip_service *ip_list,
-			int ip_count);
-int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list);
 uint64_t STR_TO_SMB_BIG_UINT(const char *nptr, const char **entptr);
 uint64_t conv_str_size(const char * str);
 int asprintf_strupper_m(char **strp, const char *fmt, ...)
diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 6a4bbc7216f..3b77c748527 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -97,7 +97,7 @@ static char *ipstr_list_add(char **ipstr_list, const struct ip_service *service)
  * @return pointer to allocated ip string
  **/
 
-char *ipstr_list_make(char **ipstr_list,
+static char *ipstr_list_make(char **ipstr_list,
 			const struct ip_service *ip_list,
 			int ip_count)
 {
@@ -130,7 +130,7 @@ char *ipstr_list_make(char **ipstr_list,
  * @return number of successfully parsed addresses
  **/
 
-int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
+static int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
 {
 	TALLOC_CTX *frame;
 	char *token_str = NULL;
-- 
2.20.1


From 86f6249b7d7d26f097b1bf78a2b4517a7f09a39e Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 12:12:23 -0700
Subject: [PATCH 04/62] s3: libsmb: Cleanup modern coding standards.
 'True/False' -> 'true/false'.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 24 ++++++++++++------------
 1 file changed, 12 insertions(+), 12 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 3b77c748527..832daea1e01 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -221,7 +221,7 @@ bool namecache_store(const char *name,
 	bool ret;
 
 	if (name_type > 255) {
-		return False; /* Don't store non-real name types. */
+		return false; /* Don't store non-real name types. */
 	}
 
 	if ( DEBUGLEVEL >= 5 ) {
@@ -247,7 +247,7 @@ bool namecache_store(const char *name,
 
 	key = namecache_key(name, name_type);
 	if (!key) {
-		return False;
+		return false;
 	}
 
 	expiry = time(NULL) + lp_name_cache_timeout();
@@ -293,11 +293,11 @@ bool namecache_fetch(const char *name,
 
 	/* exit now if null pointers were passed as they're required further */
 	if (!ip_list || !num_names) {
-		return False;
+		return false;
 	}
 
 	if (name_type > 255) {
-		return False; /* Don't fetch non-real name types. */
+		return false; /* Don't fetch non-real name types. */
 	}
 
 	*num_names = 0;
@@ -307,13 +307,13 @@ bool namecache_fetch(const char *name,
 	 */
 	key = namecache_key(name, name_type);
 	if (!key) {
-		return False;
+		return false;
 	}
 
 	if (!gencache_get(key, talloc_tos(), &value, &timeout)) {
 		DEBUG(5, ("no entry for %s#%02X found.\n", name, name_type));
 		SAFE_FREE(key);
-		return False;
+		return false;
 	}
 
 	DEBUG(5, ("name %s#%02X found.\n", name, name_type));
@@ -340,12 +340,12 @@ bool namecache_delete(const char *name, int name_type)
 	char *key;
 
 	if (name_type > 255) {
-		return False; /* Don't fetch non-real name types. */
+		return false; /* Don't fetch non-real name types. */
 	}
 
 	key = namecache_key(name, name_type);
 	if (!key) {
-		return False;
+		return false;
 	}
 	ret = gencache_del(key);
 	SAFE_FREE(key);
@@ -414,7 +414,7 @@ bool namecache_status_store(const char *keyname, int keyname_type,
 	key = namecache_status_record_key(keyname, keyname_type,
 			name_type, keyip);
 	if (!key)
-		return False;
+		return false;
 
 	expiry = time(NULL) + lp_name_cache_timeout();
 	ret = gencache_set(key, srvname, expiry);
@@ -446,13 +446,13 @@ bool namecache_status_fetch(const char *keyname,
 	key = namecache_status_record_key(keyname, keyname_type,
 			name_type, keyip);
 	if (!key)
-		return False;
+		return false;
 
 	if (!gencache_get(key, talloc_tos(), &value, &timeout)) {
 		DEBUG(5, ("namecache_status_fetch: no entry for %s found.\n",
 					key));
 		SAFE_FREE(key);
-		return False;
+		return false;
 	} else {
 		DEBUG(5, ("namecache_status_fetch: key %s -> %s\n",
 					key, value ));
@@ -461,5 +461,5 @@ bool namecache_status_fetch(const char *keyname,
 	strlcpy(srvname_out, value, 16);
 	SAFE_FREE(key);
 	TALLOC_FREE(value);
-	return True;
+	return true;
 }
-- 
2.20.1


From 52405b7dbd76fa3daf5e5e415928ecd4220ae824 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 13:28:33 -0700
Subject: [PATCH 05/62] s3: libsmb: Cleanup - move talloc frame out of inner
 scope.

Make it available thoughout the function. Prepare to use
talloc for namecache_key().

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 832daea1e01..76d411e87d1 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -219,20 +219,21 @@ bool namecache_store(const char *name,
 	char *key, *value_string;
 	int i;
 	bool ret;
+	TALLOC_CTX *frame = talloc_stackframe();
 
 	if (name_type > 255) {
+		TALLOC_FREE(frame);
 		return false; /* Don't store non-real name types. */
 	}
 
 	if ( DEBUGLEVEL >= 5 ) {
-		TALLOC_CTX *ctx = talloc_stackframe();
 		char *addr = NULL;
 
 		DEBUG(5, ("namecache_store: storing %d address%s for %s#%02x: ",
 			num_names, num_names == 1 ? "": "es", name, name_type));
 
 		for (i = 0; i < num_names; i++) {
-			addr = print_canonical_sockaddr(ctx,
+			addr = print_canonical_sockaddr(frame,
 							&ip_list[i].ss);
 			if (!addr) {
 				continue;
@@ -242,11 +243,11 @@ bool namecache_store(const char *name,
 
 		}
 		DEBUGADD(5, ("\n"));
-		TALLOC_FREE(ctx);
 	}
 
 	key = namecache_key(name, name_type);
 	if (!key) {
+		TALLOC_FREE(frame);
 		return false;
 	}
 
@@ -260,6 +261,7 @@ bool namecache_store(const char *name,
 	if (!ipstr_list_make(&value_string, ip_list, num_names)) {
 		SAFE_FREE(key);
 		SAFE_FREE(value_string);
+		TALLOC_FREE(frame);
 		return false;
 	}
 
@@ -267,6 +269,7 @@ bool namecache_store(const char *name,
 	ret = gencache_set(key, value_string, expiry);
 	SAFE_FREE(key);
 	SAFE_FREE(value_string);
+	TALLOC_FREE(frame);
 	return ret;
 }
 
-- 
2.20.1


From cf885843fca6c60fb855b9c56f560bc70536ea1d Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 13:31:38 -0700
Subject: [PATCH 06/62] s3: libsmb: Cleanup - namecache_store() initialize
 stack variables.

Preparing for common out: exit.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 76d411e87d1..1127874c375 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -216,9 +216,10 @@ bool namecache_store(const char *name,
 			struct ip_service *ip_list)
 {
 	time_t expiry;
-	char *key, *value_string;
+	char *key = NULL;
+	char *value_string = NULL;
 	int i;
-	bool ret;
+	bool ret = false;
 	TALLOC_CTX *frame = talloc_stackframe();
 
 	if (name_type > 255) {
-- 
2.20.1


From a464af6d2363714c631e62e390b5bbef81fa03c0 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 13:33:27 -0700
Subject: [PATCH 07/62] s3: libsmb: Cleanup - namecache_store() - use common
 out.

Prepare for moving malloc values to talloc.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 1127874c375..a4de493b08e 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -223,8 +223,8 @@ bool namecache_store(const char *name,
 	TALLOC_CTX *frame = talloc_stackframe();
 
 	if (name_type > 255) {
-		TALLOC_FREE(frame);
-		return false; /* Don't store non-real name types. */
+		/* Don't store non-real name types. */
+		goto out;
 	}
 
 	if ( DEBUGLEVEL >= 5 ) {
@@ -248,8 +248,7 @@ bool namecache_store(const char *name,
 
 	key = namecache_key(name, name_type);
 	if (!key) {
-		TALLOC_FREE(frame);
-		return false;
+		goto out;
 	}
 
 	expiry = time(NULL) + lp_name_cache_timeout();
@@ -260,14 +259,14 @@ bool namecache_store(const char *name,
 	 * place each single ip
 	 */
 	if (!ipstr_list_make(&value_string, ip_list, num_names)) {
-		SAFE_FREE(key);
-		SAFE_FREE(value_string);
-		TALLOC_FREE(frame);
-		return false;
+		goto out;
 	}
 
 	/* set the entry */
 	ret = gencache_set(key, value_string, expiry);
+
+  out:
+
 	SAFE_FREE(key);
 	SAFE_FREE(value_string);
 	TALLOC_FREE(frame);
-- 
2.20.1


From cb2876a6fc29880c4f8cb50e96fc36cc0eaa1aba Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 13:37:59 -0700
Subject: [PATCH 08/62] s3: libsmb: Cleanup - make namecache_key() use talloc.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 27 ++++++++++++++-------------
 1 file changed, 14 insertions(+), 13 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index a4de493b08e..5457a9d47cc 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -191,13 +191,14 @@ static int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
  *         type number
  */
 
-static char *namecache_key(const char *name,
-				int name_type)
+static char *namecache_key(TALLOC_CTX *ctx,
+			   const char *name,
+			   int name_type)
 {
-	char *keystr = NULL;
-	asprintf_strupper_m(&keystr, NBTKEY_FMT, name, name_type);
-
-	return keystr;
+	return talloc_asprintf_strupper_m(ctx,
+					  NBTKEY_FMT,
+					  name,
+					  name_type);
 }
 
 /**
@@ -246,7 +247,7 @@ bool namecache_store(const char *name,
 		DEBUGADD(5, ("\n"));
 	}
 
-	key = namecache_key(name, name_type);
+	key = namecache_key(frame, name, name_type);
 	if (!key) {
 		goto out;
 	}
@@ -267,7 +268,7 @@ bool namecache_store(const char *name,
 
   out:
 
-	SAFE_FREE(key);
+	TALLOC_FREE(key);
 	SAFE_FREE(value_string);
 	TALLOC_FREE(frame);
 	return ret;
@@ -308,14 +309,14 @@ bool namecache_fetch(const char *name,
 	/*
 	 * Use gencache interface - lookup the key
 	 */
-	key = namecache_key(name, name_type);
+	key = namecache_key(talloc_tos(), name, name_type);
 	if (!key) {
 		return false;
 	}
 
 	if (!gencache_get(key, talloc_tos(), &value, &timeout)) {
 		DEBUG(5, ("no entry for %s#%02X found.\n", name, name_type));
-		SAFE_FREE(key);
+		TALLOC_FREE(key);
 		return false;
 	}
 
@@ -326,7 +327,7 @@ bool namecache_fetch(const char *name,
 	 */
 	*num_names = ipstr_list_parse(value, ip_list);
 
-	SAFE_FREE(key);
+	TALLOC_FREE(key);
 	TALLOC_FREE(value);
 
 	return *num_names > 0; /* true only if some ip has been fetched */
@@ -346,12 +347,12 @@ bool namecache_delete(const char *name, int name_type)
 		return false; /* Don't fetch non-real name types. */
 	}
 
-	key = namecache_key(name, name_type);
+	key = namecache_key(talloc_tos(), name, name_type);
 	if (!key) {
 		return false;
 	}
 	ret = gencache_del(key);
-	SAFE_FREE(key);
+	TALLOC_FREE(key);
 	return ret;
 }
 
-- 
2.20.1


From 36bf9a7373d058e5f7b07c3d9f0f7b8661615a62 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 14:38:23 -0700
Subject: [PATCH 09/62] s3: libsmb: Cleanup - make
 namecache_status_record_key() use talloc.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 33 +++++++++++++++++++++------------
 1 file changed, 21 insertions(+), 12 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 5457a9d47cc..ed0d116e3bb 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -391,18 +391,21 @@ void namecache_flush(void)
 
 /* Construct a name status record key. */
 
-static char *namecache_status_record_key(const char *name,
+static char *namecache_status_record_key(TALLOC_CTX *ctx,
+				const char *name,
 				int name_type1,
 				int name_type2,
 				const struct sockaddr_storage *keyip)
 {
 	char addr[INET6_ADDRSTRLEN];
-	char *keystr = NULL;
 
 	print_sockaddr(addr, sizeof(addr), keyip);
-	asprintf_strupper_m(&keystr, "NBT/%s#%02X.%02X.%s", name,
-			    name_type1, name_type2, addr);
-	return keystr;
+	return talloc_asprintf_strupper_m(ctx,
+					  "NBT/%s#%02X.%02X.%s",
+					  name,
+					  name_type1,
+					  name_type2,
+					  addr);
 }
 
 /* Store a name status record. */
@@ -415,8 +418,11 @@ bool namecache_status_store(const char *keyname, int keyname_type,
 	time_t expiry;
 	bool ret;
 
-	key = namecache_status_record_key(keyname, keyname_type,
-			name_type, keyip);
+	key = namecache_status_record_key(talloc_tos(),
+					  keyname,
+					  keyname_type,
+					  name_type,
+					  keyip);
 	if (!key)
 		return false;
 
@@ -431,7 +437,7 @@ bool namecache_status_store(const char *keyname, int keyname_type,
 					key ));
 	}
 
-	SAFE_FREE(key);
+	TALLOC_FREE(key);
 	return ret;
 }
 
@@ -447,15 +453,18 @@ bool namecache_status_fetch(const char *keyname,
 	char *value = NULL;
 	time_t timeout;
 
-	key = namecache_status_record_key(keyname, keyname_type,
-			name_type, keyip);
+	key = namecache_status_record_key(talloc_tos(),
+					  keyname,
+					  keyname_type,
+					  name_type,
+					  keyip);
 	if (!key)
 		return false;
 
 	if (!gencache_get(key, talloc_tos(), &value, &timeout)) {
 		DEBUG(5, ("namecache_status_fetch: no entry for %s found.\n",
 					key));
-		SAFE_FREE(key);
+		TALLOC_FREE(key);
 		return false;
 	} else {
 		DEBUG(5, ("namecache_status_fetch: key %s -> %s\n",
@@ -463,7 +472,7 @@ bool namecache_status_fetch(const char *keyname,
 	}
 
 	strlcpy(srvname_out, value, 16);
-	SAFE_FREE(key);
+	TALLOC_FREE(key);
 	TALLOC_FREE(value);
 	return true;
 }
-- 
2.20.1


From c796efc01c89c6da7ab0e1565195aeeee54e04cc Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 14:41:45 -0700
Subject: [PATCH 10/62] s3: libsmb: Cleanup - Move DEBUG -> DBG_XXX() macros.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 28 ++++++++++++----------------
 1 file changed, 12 insertions(+), 16 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index ed0d116e3bb..3c1a376b35b 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -141,8 +141,8 @@ static int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
 
 	count = count_chars(ipstr_list, IPSTR_LIST_CHAR) + 1;
 	if ( (*ip_list = SMB_MALLOC_ARRAY(struct ip_service, count)) == NULL ) {
-		DEBUG(0,("ipstr_list_parse: malloc failed for %lu entries\n",
-					(unsigned long)count));
+		DBG_ERR("malloc failed for %lu entries\n",
+					(unsigned long)count);
 		return 0;
 	}
 
@@ -231,8 +231,8 @@ bool namecache_store(const char *name,
 	if ( DEBUGLEVEL >= 5 ) {
 		char *addr = NULL;
 
-		DEBUG(5, ("namecache_store: storing %d address%s for %s#%02x: ",
-			num_names, num_names == 1 ? "": "es", name, name_type));
+		DBG_INFO("storing %d address%s for %s#%02x: ",
+			num_names, num_names == 1 ? "": "es", name, name_type);
 
 		for (i = 0; i < num_names; i++) {
 			addr = print_canonical_sockaddr(frame,
@@ -315,12 +315,12 @@ bool namecache_fetch(const char *name,
 	}
 
 	if (!gencache_get(key, talloc_tos(), &value, &timeout)) {
-		DEBUG(5, ("no entry for %s#%02X found.\n", name, name_type));
+		DBG_INFO("no entry for %s#%02X found.\n", name, name_type);
 		TALLOC_FREE(key);
 		return false;
 	}
 
-	DEBUG(5, ("name %s#%02X found.\n", name, name_type));
+	DBG_INFO("name %s#%02X found.\n", name, name_type);
 
 	/*
 	 * Split up the stored value into the list of IP adresses
@@ -368,7 +368,7 @@ static void flush_netbios_name(const char *key,
 			void *dptr)
 {
 	gencache_del(key);
-	DEBUG(5, ("Deleting entry %s\n", key));
+	DBG_INFO("Deleting entry %s\n", key);
 }
 
 /**
@@ -386,7 +386,7 @@ void namecache_flush(void)
 	 * by flush_netbios_name function
 	 */
 	gencache_iterate(flush_netbios_name, NULL, "NBT/*");
-	DEBUG(5, ("Namecache flushed\n"));
+	DBG_INFO("Namecache flushed\n");
 }
 
 /* Construct a name status record key. */
@@ -430,11 +430,9 @@ bool namecache_status_store(const char *keyname, int keyname_type,
 	ret = gencache_set(key, srvname, expiry);
 
 	if (ret) {
-		DEBUG(5, ("namecache_status_store: entry %s -> %s\n",
-					key, srvname ));
+		DBG_INFO("entry %s -> %s\n", key, srvname);
 	} else {
-		DEBUG(5, ("namecache_status_store: entry %s store failed.\n",
-					key ));
+		DBG_INFO("entry %s store failed.\n", key);
 	}
 
 	TALLOC_FREE(key);
@@ -462,13 +460,11 @@ bool namecache_status_fetch(const char *keyname,
 		return false;
 
 	if (!gencache_get(key, talloc_tos(), &value, &timeout)) {
-		DEBUG(5, ("namecache_status_fetch: no entry for %s found.\n",
-					key));
+		DBG_INFO("no entry for %s found.\n", key);
 		TALLOC_FREE(key);
 		return false;
 	} else {
-		DEBUG(5, ("namecache_status_fetch: key %s -> %s\n",
-					key, value ));
+		DBG_INFO("key %s -> %s\n", key, value);
 	}
 
 	strlcpy(srvname_out, value, 16);
-- 
2.20.1


From 9a9ed170a5e3ed30cab22daf3a4440ea1350982b Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 15:02:02 -0700
Subject: [PATCH 11/62] s3: libsmb: Cleanup - Make ipstr_list_make() talloc
 rather than malloc.

Remove the excessive and unneeded ipstr_list_add() function,
fold it into ipstr_list_make() to make it much clearer what
we're doing.

The only use of MALLOC now is in ipstr_list_parse() returned
by namecache_fetch(). We need to fix the caller before
we can move that to talloc. As that is used inside internal_resolve_name()
which is designed to return a MALLOC'ed ip list from all
name resolution mechanisms leave that fix for another day.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>

Autobuild-User(master): Volker Lendecke <vl@samba.org>
Autobuild-Date(master): Thu Jul 16 08:16:31 UTC 2020 on sn-devel-184
---
 source3/libsmb/namecache.c | 133 +++++++++++++++++--------------------
 1 file changed, 60 insertions(+), 73 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 3c1a376b35b..7f534587263 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -27,98 +27,86 @@
 #define IPSTR_LIST_SEP	","
 #define IPSTR_LIST_CHAR	','
 
-/**
- * Add ip string representation to ipstr list. Used also
- * as part of @function ipstr_list_make
- *
- * @param ipstr_list pointer to string containing ip list;
- *        MUST BE already allocated and IS reallocated if necessary
- * @param ipstr_size pointer to current size of ipstr_list (might be changed
- *        as a result of reallocation)
- * @param ip IP address which is to be added to list
- * @return pointer to string appended with new ip and possibly
- *         reallocated to new length
- **/
-
-static char *ipstr_list_add(char **ipstr_list, const struct ip_service *service)
-{
-	char *new_ipstr = NULL;
-	char addr_buf[INET6_ADDRSTRLEN];
-	int ret;
-
-	/* arguments checking */
-	if (!ipstr_list || !service) {
-		return NULL;
-	}
-
-	print_sockaddr(addr_buf,
-			sizeof(addr_buf),
-			&service->ss);
-
-	/* attempt to convert ip to a string and append colon separator to it */
-	if (*ipstr_list) {
-		if (service->ss.ss_family == AF_INET) {
-			/* IPv4 */
-			ret = asprintf(&new_ipstr, "%s%s%s:%d",	*ipstr_list,
-				       IPSTR_LIST_SEP, addr_buf,
-				       service->port);
-		} else {
-			/* IPv6 */
-			ret = asprintf(&new_ipstr, "%s%s[%s]:%d", *ipstr_list,
-				       IPSTR_LIST_SEP, addr_buf,
-				       service->port);
-		}
-		SAFE_FREE(*ipstr_list);
-	} else {
-		if (service->ss.ss_family == AF_INET) {
-			/* IPv4 */
-			ret = asprintf(&new_ipstr, "%s:%d", addr_buf,
-				       service->port);
-		} else {
-			/* IPv6 */
-			ret = asprintf(&new_ipstr, "[%s]:%d", addr_buf,
-				       service->port);
-		}
-	}
-	if (ret == -1) {
-		return NULL;
-	}
-	*ipstr_list = new_ipstr;
-	return *ipstr_list;
-}
-
 /**
  * Allocate and initialise an ipstr list using ip adresses
  * passed as arguments.
  *
- * @param ipstr_list pointer to string meant to be allocated and set
+ * @param ctx TALLOC_CTX to use
  * @param ip_list array of ip addresses to place in the list
  * @param ip_count number of addresses stored in ip_list
  * @return pointer to allocated ip string
  **/
 
-static char *ipstr_list_make(char **ipstr_list,
+static char *ipstr_list_make(TALLOC_CTX *ctx,
 			const struct ip_service *ip_list,
 			int ip_count)
 {
+	char *ipstr_list = NULL;
 	int i;
 
 	/* arguments checking */
-	if (!ip_list || !ipstr_list) {
-		return 0;
+	if (ip_list == NULL) {
+		return NULL;
 	}
 
-	*ipstr_list = NULL;
-
 	/* process ip addresses given as arguments */
 	for (i = 0; i < ip_count; i++) {
-		*ipstr_list = ipstr_list_add(ipstr_list, &ip_list[i]);
+		char addr_buf[INET6_ADDRSTRLEN];
+		char *new_str = NULL;
+
+		print_sockaddr(addr_buf,
+			       sizeof(addr_buf),
+			       &ip_list[i].ss);
+
+		if (ip_list->ss.ss_family == AF_INET) {
+			/* IPv4 */
+			new_str = talloc_asprintf(ctx,
+						  "%s:%d",
+						  addr_buf,
+						  ip_list[i].port);
+		} else {
+			/* IPv6 */
+			new_str = talloc_asprintf(ctx,
+						  "[%s]:%d",
+						  addr_buf,
+						  ip_list[i].port);
+		}
+		if (new_str == NULL) {
+			TALLOC_FREE(ipstr_list);
+			return NULL;
+		}
+
+		if (ipstr_list == NULL) {
+			/* First ip address. */
+			ipstr_list = new_str;
+		} else {
+			/*
+			 * Append the separator "," and then the new
+			 * ip address to the existing list.
+			 *
+			 * The efficiency here is horrible, but
+			 * ip_count should be small enough we can
+			 * live with it.
+			 */
+			char *tmp = talloc_asprintf(ctx,
+						    "%s%s%s",
+						    ipstr_list,
+						    IPSTR_LIST_SEP,
+						    new_str);
+			if (tmp == NULL) {
+				TALLOC_FREE(new_str);
+				TALLOC_FREE(ipstr_list);
+				return NULL;
+			}
+			TALLOC_FREE(new_str);
+			TALLOC_FREE(ipstr_list);
+			ipstr_list = tmp;
+		}
 	}
 
-	return (*ipstr_list);
+	return ipstr_list;
 }
 
-
 /**
  * Parse given ip string list into array of ip addresses
  * (as ip_service structures)
@@ -256,10 +244,9 @@ bool namecache_store(const char *name,
 
 	/*
 	 * Generate string representation of ip addresses list
-	 * First, store the number of ip addresses and then
-	 * place each single ip
 	 */
-	if (!ipstr_list_make(&value_string, ip_list, num_names)) {
+	value_string = ipstr_list_make(frame, ip_list, num_names);
+	if (value_string == NULL) {
 		goto out;
 	}
 
@@ -269,7 +256,7 @@ bool namecache_store(const char *name,
   out:
 
 	TALLOC_FREE(key);
-	SAFE_FREE(value_string);
+	TALLOC_FREE(value_string);
 	TALLOC_FREE(frame);
 	return ret;
 }
-- 
2.20.1


From 7ba2c859ce3f6863da9b31454377d23d6b64fdf8 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Thu, 16 Jul 2020 15:47:04 -0700
Subject: [PATCH 12/62] s3: libsmb: Namecache. Fix bug missed by me in previous
 cleanup.

In ipstr_list_make() we need to look at the correct array entry
to determine the ss_family for the sockaddr_storage.

Otherwise we are always storing the type of the first entry.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>

Autobuild-User(master): Volker Lendecke <vl@samba.org>
Autobuild-Date(master): Fri Jul 17 05:54:31 UTC 2020 on sn-devel-184
---
 source3/libsmb/namecache.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 7f534587263..fb4a4aac8c8 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -58,7 +58,7 @@ static char *ipstr_list_make(TALLOC_CTX *ctx,
 			       sizeof(addr_buf),
 			       &ip_list[i].ss);
 
-		if (ip_list->ss.ss_family == AF_INET) {
+		if (ip_list[i].ss.ss_family == AF_INET) {
 			/* IPv4 */
 			new_str = talloc_asprintf(ctx,
 						  "%s:%d",
-- 
2.20.1


From cd671fcfc167061b2af279e3f138d32600c51ec5 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 20:57:44 -0700
Subject: [PATCH 13/62] s3: libsmb: Cleanup - ensure we don't try and continue
 resolving names on failure of convert_ss2service().

Logic change, but correct error cleanup - jump to new 'fail:' label.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index f61e2507cce..eba696b621d 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2672,6 +2672,7 @@ NTSTATUS internal_resolve_name(const char *name,
 							ss_list,
 							return_count)) {
 					status = NT_STATUS_NO_MEMORY;
+					goto fail;
 				}
 				goto done;
 			}
@@ -2704,6 +2705,7 @@ NTSTATUS internal_resolve_name(const char *name,
 							ss_list,
 							return_count)) {
 					status = NT_STATUS_NO_MEMORY;
+					goto fail;
 				}
 				goto done;
 			}
@@ -2720,6 +2722,7 @@ NTSTATUS internal_resolve_name(const char *name,
 								ss_list,
 								return_count)) {
 						status = NT_STATUS_NO_MEMORY;
+						goto fail;
 					}
 					goto done;
 				}
@@ -2734,6 +2737,7 @@ NTSTATUS internal_resolve_name(const char *name,
 							ss_list,
 							return_count)) {
 					status = NT_STATUS_NO_MEMORY;
+					goto fail;
 				}
 				goto done;
 			}
@@ -2745,6 +2749,8 @@ NTSTATUS internal_resolve_name(const char *name,
 
 	/* All of the resolve_* functions above have returned false. */
 
+  fail:
+
 	TALLOC_FREE(frame);
 	SAFE_FREE(*return_iplist);
 	*return_count = 0;
-- 
2.20.1


From 2909432a288344e5717c1f803bd9f191869eb004 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 16:54:45 -0700
Subject: [PATCH 14/62] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for resolve_hosts().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index eba696b621d..1af78218bb2 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2667,15 +2667,16 @@ NTSTATUS internal_resolve_name(const char *name,
 			status = resolve_hosts(name, name_type,
 					       talloc_tos(), &ss_list,
 					       return_count);
-			if (NT_STATUS_IS_OK(status)) {
-				if (!convert_ss2service(return_iplist,
-							ss_list,
-							return_count)) {
-					status = NT_STATUS_NO_MEMORY;
-					goto fail;
-				}
-				goto done;
+			if (!NT_STATUS_IS_OK(status)) {
+				continue;
+			}
+			if (!convert_ss2service(return_iplist,
+						ss_list,
+						return_count)) {
+				status = NT_STATUS_NO_MEMORY;
+				goto fail;
 			}
+			goto done;
 		} else if(strequal( tok, "kdc")) {
 			/* deal with KDC_NAME_TYPE names here.
 			 * This will result in a SRV record lookup */
-- 
2.20.1


From 350998d49c97c8a8eb7ff942333f324464980d19 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 16:56:14 -0700
Subject: [PATCH 15/62] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for KDC resolve_ads().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 1af78218bb2..c4ab345e30a 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2682,12 +2682,13 @@ NTSTATUS internal_resolve_name(const char *name,
 			 * This will result in a SRV record lookup */
 			status = resolve_ads(name, KDC_NAME_TYPE, sitename,
 					     return_iplist, return_count);
-			if (NT_STATUS_IS_OK(status)) {
-				/* Ensure we don't namecache
-				 * this with the KDC port. */
-				name_type = KDC_NAME_TYPE;
-				goto done;
+			if (!NT_STATUS_IS_OK(status)) {
+				continue;
 			}
+			/* Ensure we don't namecache
+			 * this with the KDC port. */
+			name_type = KDC_NAME_TYPE;
+			goto done;
 		} else if(strequal( tok, "ads")) {
 			/* deal with 0x1c and 0x1b names here.
 			 * This will result in a SRV record lookup */
-- 
2.20.1


From bba87d43b5bea1242d3dd995920c7e14feaf4d34 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 16:57:43 -0700
Subject: [PATCH 16/62] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for resolve_ads().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index c4ab345e30a..7f105abd402 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2694,9 +2694,10 @@ NTSTATUS internal_resolve_name(const char *name,
 			 * This will result in a SRV record lookup */
 			status = resolve_ads(name, name_type, sitename,
 					     return_iplist, return_count);
-			if (NT_STATUS_IS_OK(status)) {
-				goto done;
+			if (!NT_STATUS_IS_OK(status)) {
+				continue;
 			}
+			goto done;
 		} else if (strequal(tok, "lmhosts")) {
 			struct sockaddr_storage *ss_list;
 			status = resolve_lmhosts_file_as_sockaddr(
-- 
2.20.1


From 6e11470e88462a657f5a9de27fe3d1f750fce366 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 16:58:46 -0700
Subject: [PATCH 17/62] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for resolve_lmhosts_file_as_sockaddr().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 7f105abd402..319ae952d7f 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2703,15 +2703,16 @@ NTSTATUS internal_resolve_name(const char *name,
 			status = resolve_lmhosts_file_as_sockaddr(
 				get_dyn_LMHOSTSFILE(), name, name_type,
 				talloc_tos(), &ss_list, return_count);
-			if (NT_STATUS_IS_OK(status)) {
-				if (!convert_ss2service(return_iplist,
-							ss_list,
-							return_count)) {
-					status = NT_STATUS_NO_MEMORY;
-					goto fail;
-				}
-				goto done;
+			if (!NT_STATUS_IS_OK(status)) {
+				continue;
+			}
+			if (!convert_ss2service(return_iplist,
+						ss_list,
+						return_count)) {
+				status = NT_STATUS_NO_MEMORY;
+				goto fail;
 			}
+			goto done;
 		} else if (strequal(tok, "wins")) {
 			/* don't resolve 1D via WINS */
 			struct sockaddr_storage *ss_list;
-- 
2.20.1


From bab5e02b1623b5c24a88a588cce22dcf9a5babde Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 16:59:38 -0700
Subject: [PATCH 18/62] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for 0x1D name in resolve_wins().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 27 ++++++++++++++-------------
 1 file changed, 14 insertions(+), 13 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 319ae952d7f..95d17b6ebea 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2716,20 +2716,21 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if (strequal(tok, "wins")) {
 			/* don't resolve 1D via WINS */
 			struct sockaddr_storage *ss_list;
-			if (name_type != 0x1D) {
-				status = resolve_wins(name, name_type,
-						      talloc_tos(),
-						      &ss_list,
-						      return_count);
-				if (NT_STATUS_IS_OK(status)) {
-					if (!convert_ss2service(return_iplist,
-								ss_list,
-								return_count)) {
-						status = NT_STATUS_NO_MEMORY;
-						goto fail;
-					}
-					goto done;
+			if (name_type == 0x1D) {
+				continue;
+			}
+			status = resolve_wins(name, name_type,
+					      talloc_tos(),
+					      &ss_list,
+					      return_count);
+			if (NT_STATUS_IS_OK(status)) {
+				if (!convert_ss2service(return_iplist,
+							ss_list,
+							return_count)) {
+					status = NT_STATUS_NO_MEMORY;
+					goto fail;
 				}
+				goto done;
 			}
 		} else if (strequal(tok, "bcast")) {
 			struct sockaddr_storage *ss_list;
-- 
2.20.1


From 8562a23690aff9098f100584bc0762c3b3941cb7 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:00:35 -0700
Subject: [PATCH 19/62] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for resolve_wins().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 95d17b6ebea..ffc36b0acf5 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2723,15 +2723,16 @@ NTSTATUS internal_resolve_name(const char *name,
 					      talloc_tos(),
 					      &ss_list,
 					      return_count);
-			if (NT_STATUS_IS_OK(status)) {
-				if (!convert_ss2service(return_iplist,
-							ss_list,
-							return_count)) {
-					status = NT_STATUS_NO_MEMORY;
-					goto fail;
-				}
-				goto done;
+			if (!NT_STATUS_IS_OK(status)) {
+				continue;
+			}
+			if (!convert_ss2service(return_iplist,
+						ss_list,
+						return_count)) {
+				status = NT_STATUS_NO_MEMORY;
+				goto fail;
 			}
+			goto done;
 		} else if (strequal(tok, "bcast")) {
 			struct sockaddr_storage *ss_list;
 			status = name_resolve_bcast(
-- 
2.20.1


From 748afd2d3770e0946034c1fe52734556b31ebf86 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:01:04 -0700
Subject: [PATCH 20/62] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for name_resolve_bcast().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index ffc36b0acf5..9b459c58b18 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2738,15 +2738,16 @@ NTSTATUS internal_resolve_name(const char *name,
 			status = name_resolve_bcast(
 				name, name_type, talloc_tos(),
 				&ss_list, return_count);
-			if (NT_STATUS_IS_OK(status)) {
-				if (!convert_ss2service(return_iplist,
-							ss_list,
-							return_count)) {
-					status = NT_STATUS_NO_MEMORY;
-					goto fail;
-				}
-				goto done;
+			if (!NT_STATUS_IS_OK(status)) {
+				continue;
 			}
+			if (!convert_ss2service(return_iplist,
+						ss_list,
+						return_count)) {
+				status = NT_STATUS_NO_MEMORY;
+				goto fail;
+			}
+			goto done;
 		} else {
 			DEBUG(0,("resolve_name: unknown name switch type %s\n",
 				tok));
-- 
2.20.1


From 00a60fbfecc02e4694b979d995387ab384cb9cbe Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:02:15 -0700
Subject: [PATCH 21/62] s3: libsmb: Cleanup - use helper 'ok' bool for
 resolve_hosts().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 9b459c58b18..a0607269eb4 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2583,6 +2583,7 @@ NTSTATUS internal_resolve_name(const char *name,
 	const char *tok;
 	NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
 	int i;
+	bool ok;
 	TALLOC_CTX *frame = NULL;
 
 	*return_iplist = NULL;
@@ -2670,9 +2671,10 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			if (!convert_ss2service(return_iplist,
+			ok = convert_ss2service(return_iplist,
 						ss_list,
-						return_count)) {
+						return_count);
+			if (!ok) {
 				status = NT_STATUS_NO_MEMORY;
 				goto fail;
 			}
-- 
2.20.1


From 189bfcf7ac15883eeb3a6533096d73182f294654 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:03:21 -0700
Subject: [PATCH 22/62] s3: libsmb: Cleanup - use helper 'ok' bool for
 resolve_lmhosts_file_as_sockaddr().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index a0607269eb4..ce8f8f30ded 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2728,9 +2728,10 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			if (!convert_ss2service(return_iplist,
+			ok = convert_ss2service(return_iplist,
 						ss_list,
-						return_count)) {
+						return_count);
+			if (!ok) {
 				status = NT_STATUS_NO_MEMORY;
 				goto fail;
 			}
-- 
2.20.1


From 319ce53000106a8c352b2fadd2dcc4c4c1f4a9c9 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:04:57 -0700
Subject: [PATCH 23/62] s3: libsmb: Cleanup - use helper 'ok' bool for
 resolve_wins().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index ce8f8f30ded..3cc8e3e3f1b 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2744,9 +2744,10 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			if (!convert_ss2service(return_iplist,
+			ok = convert_ss2service(return_iplist,
 						ss_list,
-						return_count)) {
+						return_count);
+			if (!ok) {
 				status = NT_STATUS_NO_MEMORY;
 				goto fail;
 			}
-- 
2.20.1


From a8d3324b02622f8b8c9126968c14297b2da716f5 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:05:27 -0700
Subject: [PATCH 24/62] s3: libsmb: Cleanup - use helper 'ok' bool for
 name_resolve_bcast().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 3cc8e3e3f1b..b58d79e2e9d 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2708,9 +2708,10 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			if (!convert_ss2service(return_iplist,
+			ok = convert_ss2service(return_iplist,
 						ss_list,
-						return_count)) {
+						return_count);
+			if (!ok) {
 				status = NT_STATUS_NO_MEMORY;
 				goto fail;
 			}
-- 
2.20.1


From a8bd335d8de41f86ece4cdc9a9fc94d469ad415d Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:27:13 -0700
Subject: [PATCH 25/62] s3: libsmb: Cleanup - use helper 'ok' bool for
 internal_resolve_name().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index b58d79e2e9d..59643fa52d8 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2603,8 +2603,9 @@ NTSTATUS internal_resolve_name(const char *name,
 		(*return_iplist)->port = PORT_NONE;
 
 		/* if it's in the form of an IP address then get the lib to interpret it */
-		if (!interpret_string_addr(&(*return_iplist)->ss,
-					name, AI_NUMERICHOST)) {
+		ok = interpret_string_addr(&(*return_iplist)->ss,
+					name, AI_NUMERICHOST);
+		if (!ok) {
 			DEBUG(1,("internal_resolve_name: interpret_string_addr "
 				"failed on %s\n",
 				name));
-- 
2.20.1


From 3418e1c6e76b82ad9d02a9b67f12c6dac4736e56 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:28:41 -0700
Subject: [PATCH 26/62] s3: libsmb: Cleanup - split allocation and NULL check
 in internal_resolve_name().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 59643fa52d8..6886d0b3b2a 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2593,8 +2593,8 @@ NTSTATUS internal_resolve_name(const char *name,
 			name, name_type, sitename ? sitename : "(null)"));
 
 	if (is_ipaddress(name)) {
-		if ((*return_iplist = SMB_MALLOC_P(struct ip_service)) ==
-				NULL) {
+		*return_iplist = SMB_MALLOC_P(struct ip_service);
+		if (*return_iplist == NULL) {
 			DEBUG(0,("internal_resolve_name: malloc fail !\n"));
 			return NT_STATUS_NO_MEMORY;
 		}
-- 
2.20.1


From 9d4ed68695a37ba04a908f99718b8bd9d11f864b Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:32:47 -0700
Subject: [PATCH 27/62] s3: libsmb: Cleanup - modernize DEBUG -> DBG_ in
 internal_resolve_name()

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 21 ++++++++++-----------
 1 file changed, 10 insertions(+), 11 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 6886d0b3b2a..f69ad676bb8 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2589,13 +2589,13 @@ NTSTATUS internal_resolve_name(const char *name,
 	*return_iplist = NULL;
 	*return_count = 0;
 
-	DEBUG(10, ("internal_resolve_name: looking up %s#%x (sitename %s)\n",
-			name, name_type, sitename ? sitename : "(null)"));
+	DBG_DEBUG("looking up %s#%x (sitename %s)\n",
+		name, name_type, sitename ? sitename : "(null)");
 
 	if (is_ipaddress(name)) {
 		*return_iplist = SMB_MALLOC_P(struct ip_service);
 		if (*return_iplist == NULL) {
-			DEBUG(0,("internal_resolve_name: malloc fail !\n"));
+			DBG_ERR("malloc fail !\n");
 			return NT_STATUS_NO_MEMORY;
 		}
 
@@ -2606,9 +2606,8 @@ NTSTATUS internal_resolve_name(const char *name,
 		ok = interpret_string_addr(&(*return_iplist)->ss,
 					name, AI_NUMERICHOST);
 		if (!ok) {
-			DEBUG(1,("internal_resolve_name: interpret_string_addr "
-				"failed on %s\n",
-				name));
+			DBG_WARNING("interpret_string_addr failed on %s\n",
+				name);
 			SAFE_FREE(*return_iplist);
 			return NT_STATUS_INVALID_PARAMETER;
 		}
@@ -2636,7 +2635,7 @@ NTSTATUS internal_resolve_name(const char *name,
 	/* set the name resolution order */
 
 	if (resolve_order && strcmp(resolve_order[0], "NULL") == 0) {
-		DEBUG(8,("internal_resolve_name: all lookups disabled\n"));
+		DBG_DEBUG("all lookups disabled\n");
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
@@ -2755,8 +2754,8 @@ NTSTATUS internal_resolve_name(const char *name,
 			}
 			goto done;
 		} else {
-			DEBUG(0,("resolve_name: unknown name switch type %s\n",
-				tok));
+			DBG_ERR("unknown name switch type %s\n",
+				tok);
 		}
 	}
 
@@ -2800,8 +2799,8 @@ NTSTATUS internal_resolve_name(const char *name,
 	/* Display some debugging info */
 
 	if ( DEBUGLEVEL >= 10 ) {
-		DEBUG(10, ("internal_resolve_name: returning %d addresses: ",
-					*return_count));
+		DBG_DEBUG("returning %d addresses: ",
+				*return_count);
 
 		for (i = 0; i < *return_count; i++) {
 			char addr[INET6_ADDRSTRLEN];
-- 
2.20.1


From b0e6744808122e2bdaab4ed57ab1a44699411ab3 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:35:22 -0700
Subject: [PATCH 28/62] s3: libsmb: Cleanup - Remove incorrect comment in
 resolve_ads(). The DNS code copes fine with IPv6 addresses.

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index f69ad676bb8..a71cab8e1bf 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2387,7 +2387,6 @@ static NTSTATUS resolve_ads(const char *name,
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	/* The DNS code needs fixing to find IPv6 addresses... JRA. */
 	switch (name_type) {
 		case 0x1b:
 			DEBUG(5,("resolve_ads: Attempting to resolve "
-- 
2.20.1


From 576f5a541c858936354560b6f120b7e5f42ee848 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:38:20 -0700
Subject: [PATCH 29/62] s3: libsmb: Cleanup - reformatting resolve_hosts()
 parameters inside internal_resolve_name().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index a71cab8e1bf..8c570cebe70 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2664,8 +2664,10 @@ NTSTATUS internal_resolve_name(const char *name,
 
 		if((strequal(tok, "host") || strequal(tok, "hosts"))) {
 			struct sockaddr_storage *ss_list;
-			status = resolve_hosts(name, name_type,
-					       talloc_tos(), &ss_list,
+			status = resolve_hosts(name,
+					       name_type,
+					       talloc_tos(),
+					       &ss_list,
 					       return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
-- 
2.20.1


From 539e00d0673877e61715ae2aea7e4161091efb0d Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:39:33 -0700
Subject: [PATCH 30/62] s3: libsmb: Cleanup - reformatting resolve_ads()
 parameters inside internal_resolve_name().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 8c570cebe70..16fa764ec65 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2683,8 +2683,11 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "kdc")) {
 			/* deal with KDC_NAME_TYPE names here.
 			 * This will result in a SRV record lookup */
-			status = resolve_ads(name, KDC_NAME_TYPE, sitename,
-					     return_iplist, return_count);
+			status = resolve_ads(name,
+					     KDC_NAME_TYPE,
+					     sitename,
+					     return_iplist,
+					     return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-- 
2.20.1


From e835d41edf98f294817e90b4d5aea3694d321fc8 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:40:06 -0700
Subject: [PATCH 31/62] s3: libsmb: Cleanup - reformatting 2nd use of
 resolve_ads() parameters inside internal_resolve_name().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 16fa764ec65..2a92e530794 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2698,8 +2698,11 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "ads")) {
 			/* deal with 0x1c and 0x1b names here.
 			 * This will result in a SRV record lookup */
-			status = resolve_ads(name, name_type, sitename,
-					     return_iplist, return_count);
+			status = resolve_ads(name,
+					     name_type,
+					     sitename,
+					     return_iplist,
+					     return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-- 
2.20.1


From 614e3adeb440f8d45c84bc514412669af3a8760e Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:42:44 -0700
Subject: [PATCH 32/62] s3: libsmb: Cleanup - reformatting
 resolve_lmhosts_file_as_sockaddr() parameters inside internal_resolve_name().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 2a92e530794..30c16f349a5 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2710,8 +2710,12 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if (strequal(tok, "lmhosts")) {
 			struct sockaddr_storage *ss_list;
 			status = resolve_lmhosts_file_as_sockaddr(
-				get_dyn_LMHOSTSFILE(), name, name_type,
-				talloc_tos(), &ss_list, return_count);
+				get_dyn_LMHOSTSFILE(),
+				name,
+				name_type,
+				talloc_tos(),
+				&ss_list,
+				return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-- 
2.20.1


From d4757917dc5db5aa0cd24e229cb4165cc3fe0916 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:43:26 -0700
Subject: [PATCH 33/62] s3: libsmb: Cleanup - reformatting resolve_wins()
 parameters inside internal_resolve_name().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 30c16f349a5..bd20864a2a9 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2733,7 +2733,8 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (name_type == 0x1D) {
 				continue;
 			}
-			status = resolve_wins(name, name_type,
+			status = resolve_wins(name,
+					      name_type,
 					      talloc_tos(),
 					      &ss_list,
 					      return_count);
-- 
2.20.1


From acc88b09ae06d2aa8dc58d742fbd07fb4ea4de85 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:44:03 -0700
Subject: [PATCH 34/62] s3: libsmb: Cleanup - reformatting name_resolve_bcast()
 parameters inside internal_resolve_name().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index bd20864a2a9..1f3eba9f294 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2752,8 +2752,11 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if (strequal(tok, "bcast")) {
 			struct sockaddr_storage *ss_list;
 			status = name_resolve_bcast(
-				name, name_type, talloc_tos(),
-				&ss_list, return_count);
+						name,
+						name_type,
+						talloc_tos(),
+						&ss_list,
+						return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-- 
2.20.1


From 69e508f79e0782ff5547007773978a861096388c Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:45:44 -0700
Subject: [PATCH 35/62] s3: libsmb: Cleanup - put talloc parameter first in
 resolve_hosts().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 1f3eba9f294..2e5ecc0fb62 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2274,8 +2274,9 @@ fail:
  Resolve via "hosts" method.
 *********************************************************/
 
-static NTSTATUS resolve_hosts(const char *name, int name_type,
-			      TALLOC_CTX *mem_ctx,
+static NTSTATUS resolve_hosts(TALLOC_CTX *mem_ctx,
+			      const char *name,
+			      int name_type,
 			      struct sockaddr_storage **return_iplist,
 			      int *return_count)
 {
@@ -2664,9 +2665,9 @@ NTSTATUS internal_resolve_name(const char *name,
 
 		if((strequal(tok, "host") || strequal(tok, "hosts"))) {
 			struct sockaddr_storage *ss_list;
-			status = resolve_hosts(name,
+			status = resolve_hosts(talloc_tos(),
+					       name,
 					       name_type,
-					       talloc_tos(),
 					       &ss_list,
 					       return_count);
 			if (!NT_STATUS_IS_OK(status)) {
-- 
2.20.1


From d018b490a6a6c8b011a899d4fe4d2655d91d70ae Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:50:21 -0700
Subject: [PATCH 36/62] s3/s4: Cleanup. Move TALLOC_CTX * parameter to be first
 in resolve_lmhosts_file_as_sockaddr() to match modern conventions.

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 libcli/nbt/libnbt.h              | 7 ++++---
 libcli/nbt/lmhosts.c             | 7 ++++---
 source3/libsmb/namequery.c       | 2 +-
 source4/libcli/resolve/lmhosts.c | 8 ++++++--
 4 files changed, 15 insertions(+), 9 deletions(-)

diff --git a/libcli/nbt/libnbt.h b/libcli/nbt/libnbt.h
index f7212789897..496b2b91783 100644
--- a/libcli/nbt/libnbt.h
+++ b/libcli/nbt/libnbt.h
@@ -367,9 +367,10 @@ bool getlmhostsent(TALLOC_CTX *ctx, FILE *fp, char **pp_name, int *name_type,
 		   struct sockaddr_storage *pss);
 void endlmhosts(FILE *fp);
 
-NTSTATUS resolve_lmhosts_file_as_sockaddr(const char *lmhosts_file, 
-					  const char *name, int name_type,
-					  TALLOC_CTX *mem_ctx, 
+NTSTATUS resolve_lmhosts_file_as_sockaddr(TALLOC_CTX *mem_ctx,
+					  const char *lmhosts_file,
+					  const char *name,
+					  int name_type,
 					  struct sockaddr_storage **return_iplist,
 					  int *return_count);
 
diff --git a/libcli/nbt/lmhosts.c b/libcli/nbt/lmhosts.c
index f47d8b9804f..0890c0407d3 100644
--- a/libcli/nbt/lmhosts.c
+++ b/libcli/nbt/lmhosts.c
@@ -159,9 +159,10 @@ void endlmhosts(FILE *fp)
  Resolve via "lmhosts" method.
 *********************************************************/
 
-NTSTATUS resolve_lmhosts_file_as_sockaddr(const char *lmhosts_file,
-					  const char *name, int name_type,
-					  TALLOC_CTX *mem_ctx,
+NTSTATUS resolve_lmhosts_file_as_sockaddr(TALLOC_CTX *mem_ctx,
+					  const char *lmhosts_file,
+					  const char *name,
+					  int name_type,
 					  struct sockaddr_storage **return_iplist,
 					  int *return_count)
 {
diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 2e5ecc0fb62..0edab06fff9 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2711,10 +2711,10 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if (strequal(tok, "lmhosts")) {
 			struct sockaddr_storage *ss_list;
 			status = resolve_lmhosts_file_as_sockaddr(
+				talloc_tos(),
 				get_dyn_LMHOSTSFILE(),
 				name,
 				name_type,
-				talloc_tos(),
 				&ss_list,
 				return_count);
 			if (!NT_STATUS_IS_OK(status)) {
diff --git a/source4/libcli/resolve/lmhosts.c b/source4/libcli/resolve/lmhosts.c
index 400cf79f68b..42bdaf962f9 100644
--- a/source4/libcli/resolve/lmhosts.c
+++ b/source4/libcli/resolve/lmhosts.c
@@ -68,8 +68,12 @@ static struct composite_context *resolve_name_lmhosts_send(
 	if (composite_nomem(state, c)) return c;
 	c->private_data = state;
 
-	c->status = resolve_lmhosts_file_as_sockaddr(dyn_LMHOSTSFILE, name->name, name->type,
-						     state, &resolved_iplist, &resolved_count);
+	c->status = resolve_lmhosts_file_as_sockaddr(state,
+						     dyn_LMHOSTSFILE,
+						     name->name,
+						     name->type,
+						     &resolved_iplist,
+						     &resolved_count);
 	if (!composite_is_ok(c)) return c;
 
 	for (i=0; i < resolved_count; i++) {
-- 
2.20.1


From a2725badf688ca9907bdf730a66090e695b10115 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:53:28 -0700
Subject: [PATCH 37/62] s3: libsmb: Cleanup - put talloc parameter first in
 resolve_wins().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 8 ++++----
 source3/libsmb/namequery.h | 4 ++--
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 0edab06fff9..824f80e6b29 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2242,9 +2242,9 @@ NTSTATUS resolve_wins_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx,
  Resolve via "wins" method.
 *********************************************************/
 
-NTSTATUS resolve_wins(const char *name,
+NTSTATUS resolve_wins(TALLOC_CTX *mem_ctx,
+		const char *name,
 		int name_type,
-		TALLOC_CTX *mem_ctx,
 		struct sockaddr_storage **return_iplist,
 		int *return_count)
 {
@@ -2734,9 +2734,9 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (name_type == 0x1D) {
 				continue;
 			}
-			status = resolve_wins(name,
+			status = resolve_wins(talloc_tos(),
+					      name,
 					      name_type,
-					      talloc_tos(),
 					      &ss_list,
 					      return_count);
 			if (!NT_STATUS_IS_OK(status)) {
diff --git a/source3/libsmb/namequery.h b/source3/libsmb/namequery.h
index d7bd4d338b4..7e31dc1b632 100644
--- a/source3/libsmb/namequery.h
+++ b/source3/libsmb/namequery.h
@@ -80,9 +80,9 @@ struct tevent_req *resolve_wins_send(TALLOC_CTX *mem_ctx,
 NTSTATUS resolve_wins_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx,
 			   struct sockaddr_storage **addrs,
 			   int *num_addrs, uint8_t *flags);
-NTSTATUS resolve_wins(const char *name,
+NTSTATUS resolve_wins(TALLOC_CTX *mem_ctx,
+		const char *name,
 		int name_type,
-		TALLOC_CTX *mem_ctx,
 		struct sockaddr_storage **return_iplist,
 		int *return_count);
 NTSTATUS internal_resolve_name(const char *name,
-- 
2.20.1


From 2bb6bac68899c19d1fe0034cf66b8540eefe2022 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:56:48 -0700
Subject: [PATCH 38/62] s3: libsmb: Cleanup - put talloc parameter first in
 name_resolve_bcast().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/cliconnect.c | 7 +++++--
 source3/libsmb/libsmb_dir.c | 7 +++++--
 source3/libsmb/namequery.c  | 6 +++---
 source3/libsmb/namequery.h  | 4 ++--
 source3/utils/nmblookup.c   | 8 +++++---
 5 files changed, 20 insertions(+), 12 deletions(-)

diff --git a/source3/libsmb/cliconnect.c b/source3/libsmb/cliconnect.c
index 3df35931bb6..51ca424e206 100644
--- a/source3/libsmb/cliconnect.c
+++ b/source3/libsmb/cliconnect.c
@@ -3896,8 +3896,11 @@ struct cli_state *get_ipc_connect_master_ip_bcast(TALLOC_CTX *ctx,
 
         /* Go looking for workgroups by broadcasting on the local network */
 
-	status = name_resolve_bcast(MSBROWSE, 1, talloc_tos(),
-				    &ip_list, &count);
+	status = name_resolve_bcast(talloc_tos(),
+				MSBROWSE,
+				1,
+				&ip_list,
+				&count);
         if (!NT_STATUS_IS_OK(status)) {
                 DEBUG(99, ("No master browsers responded: %s\n",
 			   nt_errstr(status)));
diff --git a/source3/libsmb/libsmb_dir.c b/source3/libsmb/libsmb_dir.c
index fd42c71b2b8..506bfc56865 100644
--- a/source3/libsmb/libsmb_dir.c
+++ b/source3/libsmb/libsmb_dir.c
@@ -599,8 +599,11 @@ SMBC_opendir_ctx(SMBCCTX *context,
                  */
 
                 ip_list = NULL;
-		status = name_resolve_bcast(MSBROWSE, 1, talloc_tos(),
-					    &ip_list, &count);
+		status = name_resolve_bcast(talloc_tos(),
+					    MSBROWSE,
+					    1,
+					    &ip_list,
+					    &count);
                 if (!NT_STATUS_IS_OK(status))
 		{
 
diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 824f80e6b29..dde49c84d2d 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -1899,9 +1899,9 @@ NTSTATUS name_resolve_bcast_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx,
 	return NT_STATUS_OK;
 }
 
-NTSTATUS name_resolve_bcast(const char *name,
+NTSTATUS name_resolve_bcast(TALLOC_CTX *mem_ctx,
+			const char *name,
 			int name_type,
-			TALLOC_CTX *mem_ctx,
 			struct sockaddr_storage **return_iplist,
 			int *return_count)
 {
@@ -2753,9 +2753,9 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if (strequal(tok, "bcast")) {
 			struct sockaddr_storage *ss_list;
 			status = name_resolve_bcast(
+						talloc_tos(),
 						name,
 						name_type,
-						talloc_tos(),
 						&ss_list,
 						return_count);
 			if (!NT_STATUS_IS_OK(status)) {
diff --git a/source3/libsmb/namequery.h b/source3/libsmb/namequery.h
index 7e31dc1b632..aedb043ac81 100644
--- a/source3/libsmb/namequery.h
+++ b/source3/libsmb/namequery.h
@@ -68,9 +68,9 @@ struct tevent_req *name_resolve_bcast_send(TALLOC_CTX *mem_ctx,
 NTSTATUS name_resolve_bcast_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx,
 				 struct sockaddr_storage **addrs,
 				 int *num_addrs);
-NTSTATUS name_resolve_bcast(const char *name,
+NTSTATUS name_resolve_bcast(TALLOC_CTX *mem_ctx,
+			const char *name,
 			int name_type,
-			TALLOC_CTX *mem_ctx,
 			struct sockaddr_storage **return_iplist,
 			int *return_count);
 struct tevent_req *resolve_wins_send(TALLOC_CTX *mem_ctx,
diff --git a/source3/utils/nmblookup.c b/source3/utils/nmblookup.c
index c74b6497a35..2f50c5c8f5a 100644
--- a/source3/utils/nmblookup.c
+++ b/source3/utils/nmblookup.c
@@ -171,9 +171,11 @@ static bool query_one(const char *lookup, unsigned int lookup_type)
 				    &bcast_addr, talloc_tos(),
 				    &ip_list, &count, &flags);
 	} else {
-		status = name_resolve_bcast(
-			lookup, lookup_type,
-			talloc_tos(), &ip_list, &count);
+		status = name_resolve_bcast(talloc_tos(),
+					    lookup,
+					    lookup_type,
+					    &ip_list,
+					    &count);
 	}
 
 	if (!NT_STATUS_IS_OK(status)) {
-- 
2.20.1


From 2389720023132ba663fc09d911e3e2b120974238 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 20:27:38 -0700
Subject: [PATCH 39/62] s3: libsmb: Cleanup - ensure ss_list variables are
 initialized with NULL.

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index dde49c84d2d..01a2bacb9eb 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2664,7 +2664,7 @@ NTSTATUS internal_resolve_name(const char *name,
 		tok = resolve_order[i];
 
 		if((strequal(tok, "host") || strequal(tok, "hosts"))) {
-			struct sockaddr_storage *ss_list;
+			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_hosts(talloc_tos(),
 					       name,
 					       name_type,
@@ -2709,7 +2709,7 @@ NTSTATUS internal_resolve_name(const char *name,
 			}
 			goto done;
 		} else if (strequal(tok, "lmhosts")) {
-			struct sockaddr_storage *ss_list;
+			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_lmhosts_file_as_sockaddr(
 				talloc_tos(),
 				get_dyn_LMHOSTSFILE(),
@@ -2730,7 +2730,7 @@ NTSTATUS internal_resolve_name(const char *name,
 			goto done;
 		} else if (strequal(tok, "wins")) {
 			/* don't resolve 1D via WINS */
-			struct sockaddr_storage *ss_list;
+			struct sockaddr_storage *ss_list = NULL;
 			if (name_type == 0x1D) {
 				continue;
 			}
@@ -2751,7 +2751,7 @@ NTSTATUS internal_resolve_name(const char *name,
 			}
 			goto done;
 		} else if (strequal(tok, "bcast")) {
-			struct sockaddr_storage *ss_list;
+			struct sockaddr_storage *ss_list = NULL;
 			status = name_resolve_bcast(
 						talloc_tos(),
 						name,
-- 
2.20.1


From 7d7d9e9769c4bf466bcf69bd5ffe2993d7d3d2c9 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:59:20 -0700
Subject: [PATCH 40/62] s3: libsmb: Pass in TALLOC_CTX * parameter to
 resolve_ads() instead of creating one internally.

Pass in talloc_tos() to make it match the other resolve_XXX() functions.

No memory leaks as this is used for transient data and is cleaned up
when the calling frame in internal_resolve_name() is destroyed.

Preparing to have it return a talloc'ed struct sockaddr_storage array
rather than a malloc'ed struct ip_service array.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 20 ++++++--------------
 1 file changed, 6 insertions(+), 14 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 01a2bacb9eb..519bd1bf181 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2365,7 +2365,8 @@ static NTSTATUS resolve_hosts(TALLOC_CTX *mem_ctx,
 /* Special name type used to cause a _kerberos DNS lookup. */
 #define KDC_NAME_TYPE 0xDCDC
 
-static NTSTATUS resolve_ads(const char *name,
+static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
+			    const char *name,
 			    int name_type,
 			    const char *sitename,
 			    struct ip_service **return_iplist,
@@ -2373,7 +2374,6 @@ static NTSTATUS resolve_ads(const char *name,
 {
 	int 			i;
 	NTSTATUS  		status;
-	TALLOC_CTX		*ctx;
 	struct dns_rr_srv	*dcs = NULL;
 	int			numdcs = 0;
 	int			numaddrs = 0;
@@ -2383,11 +2383,6 @@ static NTSTATUS resolve_ads(const char *name,
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
-	if ( (ctx = talloc_init("resolve_ads")) == NULL ) {
-		DEBUG(0,("resolve_ads: talloc_init() failed!\n"));
-		return NT_STATUS_NO_MEMORY;
-	}
-
 	switch (name_type) {
 		case 0x1b:
 			DEBUG(5,("resolve_ads: Attempting to resolve "
@@ -2422,14 +2417,12 @@ static NTSTATUS resolve_ads(const char *name,
 	}
 
 	if ( !NT_STATUS_IS_OK( status ) ) {
-		talloc_destroy(ctx);
 		return status;
 	}
 
 	if (numdcs == 0) {
 		*return_iplist = NULL;
 		*return_count = 0;
-		talloc_destroy(ctx);
 		return NT_STATUS_OK;
 	}
 
@@ -2445,7 +2438,6 @@ static NTSTATUS resolve_ads(const char *name,
 			NULL ) {
 		DEBUG(0,("resolve_ads: malloc failed for %d entries\n",
 					numaddrs ));
-		talloc_destroy(ctx);
 		return NT_STATUS_NO_MEMORY;
 	}
 
@@ -2487,7 +2479,6 @@ static NTSTATUS resolve_ads(const char *name,
 					if (res) {
 						freeaddrinfo(res);
 					}
-					talloc_destroy(ctx);
 					return NT_STATUS_NO_MEMORY;
 				}
 			}
@@ -2526,7 +2517,6 @@ static NTSTATUS resolve_ads(const char *name,
 		}
 	}
 
-	talloc_destroy(ctx);
 	return NT_STATUS_OK;
 }
 
@@ -2684,7 +2674,8 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "kdc")) {
 			/* deal with KDC_NAME_TYPE names here.
 			 * This will result in a SRV record lookup */
-			status = resolve_ads(name,
+			status = resolve_ads(talloc_tos(),
+					     name,
 					     KDC_NAME_TYPE,
 					     sitename,
 					     return_iplist,
@@ -2699,7 +2690,8 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "ads")) {
 			/* deal with 0x1c and 0x1b names here.
 			 * This will result in a SRV record lookup */
-			status = resolve_ads(name,
+			status = resolve_ads(talloc_tos(),
+					     name,
 					     name_type,
 					     sitename,
 					     return_iplist,
-- 
2.20.1


From e3cd273a2e55adbf65cd251353646b45cf34a0be Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 18:31:16 -0700
Subject: [PATCH 41/62] s3: libsmb: Add in (currently unused) function
 dns_lookup_list().

This function takes a list of names returned from a DNS SRV
query which didn't have returned IP addresses and returns an
array of struct sockaddr_storage.

Currently synchronous, but this is the function that will
be changed to be asynchronous later.

Compiles but commented out for now so we don't get "unused
function" warnings.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 83 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 83 insertions(+)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 519bd1bf181..8a274bc5fbc 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2270,6 +2270,89 @@ fail:
 	return status;
 }
 
+#if 0
+/********************************************************
+ Resolve a list of DNS names to a list of IP addresses.
+ As this is a DC / LDAP / KDC lookup any IP address will
+ do, the requested names don't have to match the returned
+ IP address list.
+*********************************************************/
+
+static NTSTATUS dns_lookup_list(TALLOC_CTX *ctx,
+				size_t num_dns_names,
+				const char **dns_lookup_names,
+				size_t *p_num_addrs,
+				struct sockaddr_storage **pp_addrs)
+{
+	size_t total_num_addrs = 0;
+	size_t i;
+	struct sockaddr_storage *ret_addrs = NULL;
+
+	/* FIXME - make this asnyc using our async DNS code. */
+
+	for (i = 0; i < num_dns_names; i++ ) {
+		struct addrinfo *res = NULL;
+		struct addrinfo *p = NULL;
+		size_t num_addrs = 0;
+		bool ok = interpret_string_addr_internal(&res,
+					dns_lookup_names[i],
+					0);
+		if (!ok) {
+			continue;
+		}
+		/* Count the IP's returned from the lookup. */
+		for (p = res; p; p = p->ai_next) {
+			num_addrs++;
+		}
+
+		/* Wrap check. */
+		if (total_num_addrs + num_addrs < total_num_addrs) {
+			if (res) {
+				freeaddrinfo(res);
+			}
+			return NT_STATUS_INVALID_PARAMETER;
+		}
+		ret_addrs = talloc_realloc(ctx,
+					   ret_addrs,
+					   struct sockaddr_storage,
+					   total_num_addrs + num_addrs);
+		if (ret_addrs == NULL) {
+			if (res) {
+				freeaddrinfo(res);
+			}
+			return NT_STATUS_NO_MEMORY;
+		}
+
+		for (p = res; p; p = p->ai_next) {
+			char addr[INET6_ADDRSTRLEN];
+
+			memcpy(&ret_addrs[total_num_addrs],
+				p->ai_addr,
+				p->ai_addrlen);
+
+			if (is_zero_addr(&ret_addrs[total_num_addrs])) {
+				continue;
+			}
+
+			DBG_DEBUG("getaddrinfo name %s returned IP %s\n",
+				dns_lookup_names[i],
+				print_sockaddr(addr,
+					sizeof(addr),
+					&ret_addrs[total_num_addrs]));
+
+			total_num_addrs++;
+		}
+		if (res) {
+			freeaddrinfo(res);
+		}
+	}
+
+	*p_num_addrs = total_num_addrs;
+	*pp_addrs = ret_addrs;
+	return NT_STATUS_OK;
+}
+#endif
+
 /********************************************************
  Resolve via "hosts" method.
 *********************************************************/
-- 
2.20.1


From 6877f2cb238c68e5b2167196824124d0f0c16c6b Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 19:50:04 -0700
Subject: [PATCH 42/62] s3: libsmb: Rewrite resolve_ads() to use the previously
 added dns_lookup_list() function.

Clean up internals - a LOT.

This one needs careful review. Ditch the (unused) port returns from
the SRV replies.

Internally uses talloc'ed arrays of struct sockaddr_storage
which it then convert to MALLOC'ed struct ip_service.

Still returns struct ip_service but this will be
fixed in the next commit.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 242 ++++++++++++++++++++++++-------------
 1 file changed, 160 insertions(+), 82 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 8a274bc5fbc..842f82264ba 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2270,7 +2270,6 @@ fail:
 	return status;
 }
 
-#if 0
 /********************************************************
  Resolve a list of DNS names to a list of IP addresses.
  As this is a DC / LDAP / KDC lookup any IP address will
@@ -2351,7 +2350,6 @@ static NTSTATUS dns_lookup_list(TALLOC_CTX *ctx,
 	*pp_addrs = ret_addrs;
 	return NT_STATUS_OK;
 }
-#endif
 
 /********************************************************
  Resolve via "hosts" method.
@@ -2460,6 +2458,13 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	struct dns_rr_srv	*dcs = NULL;
 	int			numdcs = 0;
 	int			numaddrs = 0;
+	size_t num_srv_addrs = 0;
+	struct sockaddr_storage *srv_addrs = NULL;
+	size_t num_dns_addrs = 0;
+	struct sockaddr_storage *dns_addrs = NULL;
+	size_t num_dns_names = 0;
+	const char **dns_lookup_names = NULL;
+	struct ip_service *iplist = NULL;
 
 	if ((name_type != 0x1c) && (name_type != KDC_NAME_TYPE) &&
 	    (name_type != 0x1b)) {
@@ -2499,107 +2504,180 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 			break;
 	}
 
-	if ( !NT_STATUS_IS_OK( status ) ) {
+	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(dcs);
 		return status;
 	}
 
 	if (numdcs == 0) {
+		TALLOC_FREE(dcs);
 		*return_iplist = NULL;
 		*return_count = 0;
 		return NT_STATUS_OK;
 	}
 
-	for (i=0;i<numdcs;i++) {
-		if (!dcs[i].ss_s) {
-			numaddrs += 1;
+	/*
+	 * Split the returned values into 2 arrays. First one
+	 * is a struct sockaddr_storage array that contains results
+	 * from the SRV record lookup that contain both hostnames
+	 * and IP addresses. We only need to copy out the IP
+	 * addresses. This is srv_addrs.
+	 *
+	 * Second array contains the results from the SRV record
+	 * lookup that only contain hostnames - no IP addresses.
+	 * We must then call dns_lookup_list() to lookup
+	 * hostnames -> IP address. This is dns_addrs.
+	 *
+	 * Finally we will merge these two arrays to create the
+	 * return ip_service array.
+	 */
+
+	/* First count the sizes of each array. */
+	for(i = 0; i < numdcs; i++) {
+		if (dcs[i].ss_s != NULL) {
+			/* IP address returned in SRV record. */
+			if (num_srv_addrs + dcs[i].num_ips < num_srv_addrs) {
+				/* Wrap check. */
+				TALLOC_FREE(dcs);
+				return NT_STATUS_INVALID_PARAMETER;
+			}
+			/* Add in the number of addresses we got. */
+			num_srv_addrs += dcs[i].num_ips;
+			/*
+			 * If we got any IP addresses zero out
+			 * the hostname so we know we've already
+			 * processed this entry and won't add it
+			 * to the dns_lookup_names array we use
+			 * to do DNS queries below.
+			 */
+			dcs[i].hostname = NULL;
 		} else {
-			numaddrs += dcs[i].num_ips;
+			/* Ensure we have a hostname to lookup. */
+			if (dcs[i].hostname == NULL) {
+				continue;
+			}
+			/* No IP address returned in SRV record. */
+			if (num_dns_names + 1 < num_dns_names) {
+				/* Wrap check. */
+				TALLOC_FREE(dcs);
+				return NT_STATUS_INVALID_PARAMETER;
+			}
+			/* One more name to lookup. */
+			num_dns_names += 1;
 		}
-        }
+	}
 
-	if ((*return_iplist = SMB_MALLOC_ARRAY(struct ip_service, numaddrs)) ==
-			NULL ) {
-		DEBUG(0,("resolve_ads: malloc failed for %d entries\n",
-					numaddrs ));
+	/* Allocate the list of IP addresses we already have. */
+	srv_addrs = talloc_zero_array(ctx,
+				struct sockaddr_storage,
+				num_srv_addrs);
+	if (srv_addrs == NULL) {
+		TALLOC_FREE(dcs);
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	/* now unroll the list of IP addresses */
-
-	*return_count = 0;
+	/* Copy the addresses we already have. */
+	num_srv_addrs = 0;
+	for(i = 0; i < numdcs; i++) {
+		/* Copy all the IP addresses from the SRV response */
+		size_t j;
+		for (j = 0; j < dcs[i].num_ips; j++) {
+			char addr[INET6_ADDRSTRLEN];
 
-	for (i = 0; i < numdcs && (*return_count<numaddrs); i++ ) {
-		/* If we don't have an IP list for a name, lookup it up */
-		if (!dcs[i].ss_s) {
-			/* We need to get all IP addresses here. */
-			struct addrinfo *res = NULL;
-			struct addrinfo *p;
-			int extra_addrs = 0;
-
-			if (!interpret_string_addr_internal(&res,
-						dcs[i].hostname,
-						0)) {
+			srv_addrs[num_srv_addrs] = dcs[i].ss_s[j];
+			if (is_zero_addr(&srv_addrs[num_srv_addrs])) {
 				continue;
 			}
-			/* Add in every IP from the lookup. How
-			   many is that ? */
-			for (p = res; p; p = p->ai_next) {
-				struct sockaddr_storage ss;
-				memcpy(&ss, p->ai_addr, p->ai_addrlen);
-				if (is_zero_addr(&ss)) {
-					continue;
-				}
-				extra_addrs++;
-			}
-			if (extra_addrs > 1) {
-				/* We need to expand the return_iplist array
-				   as we only budgeted for one address. */
-				numaddrs += (extra_addrs-1);
-				*return_iplist = SMB_REALLOC_ARRAY(*return_iplist,
-						struct ip_service,
-						numaddrs);
-				if (*return_iplist == NULL) {
-					if (res) {
-						freeaddrinfo(res);
-					}
-					return NT_STATUS_NO_MEMORY;
-				}
-			}
-			for (p = res; p; p = p->ai_next) {
-				(*return_iplist)[*return_count].port = dcs[i].port;
-				memcpy(&(*return_iplist)[*return_count].ss,
-						p->ai_addr,
-						p->ai_addrlen);
-				if (is_zero_addr(&(*return_iplist)[*return_count].ss)) {
-					continue;
-				}
-				(*return_count)++;
-				/* Should never happen, but still... */
-				if (*return_count>=numaddrs) {
-					break;
-				}
-			}
-			if (res) {
-				freeaddrinfo(res);
-			}
-		} else {
-			/* use all the IP addresses from the SRV response */
-			size_t j;
-			for (j = 0; j < dcs[i].num_ips; j++) {
-				(*return_iplist)[*return_count].port = dcs[i].port;
-				(*return_iplist)[*return_count].ss = dcs[i].ss_s[j];
-				if (is_zero_addr(&(*return_iplist)[*return_count].ss)) {
-					continue;
-				}
-                                (*return_count)++;
-				/* Should never happen, but still... */
-				if (*return_count>=numaddrs) {
-					break;
-				}
-			}
+
+			DBG_DEBUG("SRV lookup %s got IP[%zu] %s\n",
+				name,
+				j,
+				print_sockaddr(addr,
+					sizeof(addr),
+					&srv_addrs[num_srv_addrs]));
+
+			num_srv_addrs++;
 		}
 	}
 
+	/* Allocate the array of hostnames we must look up. */
+	dns_lookup_names = talloc_zero_array(ctx,
+					const char *,
+					num_dns_names);
+	if (dns_lookup_names == NULL) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(srv_addrs);
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	num_dns_names = 0;
+	for(i = 0; i < numdcs; i++) {
+		if (dcs[i].hostname == NULL) {
+			/*
+			 * Must have been a SRV return with an IP address.
+			 * We don't need to look up this hostname.
+			 */
+			continue;
+                }
+		dns_lookup_names[num_dns_names] = dcs[i].hostname;
+		num_dns_names++;
+	}
+
+	/* Lookup the addresses on the dns_lookup_list. */
+	status = dns_lookup_list(ctx,
+				num_dns_names,
+				dns_lookup_names,
+				&num_dns_addrs,
+				&dns_addrs);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(srv_addrs);
+		TALLOC_FREE(dns_lookup_names);
+		return status;
+	}
+
+	/*
+	 * Combine the two sockaddr_storage arrays into a MALLOC'ed
+	 * ipservice array return.
+	 */
+
+	numaddrs = num_srv_addrs + num_dns_addrs;
+	/* Wrap check + bloody int conversion check :-(. */
+	if (numaddrs < num_srv_addrs ||
+				numaddrs < 0) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(srv_addrs);
+		TALLOC_FREE(dns_addrs);
+		TALLOC_FREE(dns_lookup_names);
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	iplist = SMB_MALLOC_ARRAY(struct ip_service, numaddrs);
+	if (iplist == NULL) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(srv_addrs);
+		TALLOC_FREE(dns_addrs);
+		TALLOC_FREE(dns_lookup_names);
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	for (i = 0; i < num_srv_addrs; i++) {
+		iplist[i].ss = srv_addrs[i];
+		iplist[i].port = 0;
+	}
+	for (i = 0; i < num_dns_addrs; i++) {
+		iplist[num_srv_addrs+i].ss = dns_addrs[i];
+		iplist[i].port = 0;
+	}
+
+	TALLOC_FREE(dcs);
+	TALLOC_FREE(srv_addrs);
+	TALLOC_FREE(dns_addrs);
+	TALLOC_FREE(dns_lookup_names);
+
+	*return_iplist = iplist;
+	*return_count = numaddrs;
 	return NT_STATUS_OK;
 }
 
-- 
2.20.1


From 1030c9708f6f89de0b6725414c847a68fb40d21a Mon Sep 17 00:00:00 2001
From: Volker Lendecke <vl@samba.org>
Date: Wed, 5 Aug 2020 16:22:10 +0200
Subject: [PATCH 43/62] libsmb: Fix CID 1465656 Resource leak

This is very likely a false positive, because Coverity does not see
that we only assign "dns_addrs" when NT_STATUS_IS_OK(status), so we
might not want this. But it is a fresh finding and looks cleaner this
way.

Signed-off-by: Volker Lendecke <vl@samba.org>
Reviewed-by: Jeremy Allison <jra@samba.org>

Autobuild-User(master): Jeremy Allison <jra@samba.org>
Autobuild-Date(master): Thu Aug  6 20:23:53 UTC 2020 on sn-devel-184
---
 source3/libsmb/namequery.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 842f82264ba..20c4c115c61 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2634,6 +2634,7 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 		TALLOC_FREE(dcs);
 		TALLOC_FREE(srv_addrs);
 		TALLOC_FREE(dns_lookup_names);
+		TALLOC_FREE(dns_addrs);
 		return status;
 	}
 
-- 
2.20.1


From 2069c53f72654dafa37faf097122dc446af83bda Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 20:17:54 -0700
Subject: [PATCH 44/62] s3: libsmb: Change resolve_ads() to return a talloc'ed
 ss_list, matching the other name resolution methods.

Now we can move all the convert_ss2service() calls to one place.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 46 +++++++++++++++++++++++++-------------
 1 file changed, 30 insertions(+), 16 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 20c4c115c61..7d6546347a6 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2450,7 +2450,7 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 			    const char *name,
 			    int name_type,
 			    const char *sitename,
-			    struct ip_service **return_iplist,
+			    struct sockaddr_storage **return_addrs,
 			    int *return_count)
 {
 	int 			i;
@@ -2464,7 +2464,7 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	struct sockaddr_storage *dns_addrs = NULL;
 	size_t num_dns_names = 0;
 	const char **dns_lookup_names = NULL;
-	struct ip_service *iplist = NULL;
+	struct sockaddr_storage *ret_addrs = NULL;
 
 	if ((name_type != 0x1c) && (name_type != KDC_NAME_TYPE) &&
 	    (name_type != 0x1b)) {
@@ -2511,7 +2511,7 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 
 	if (numdcs == 0) {
 		TALLOC_FREE(dcs);
-		*return_iplist = NULL;
+		*return_addrs = NULL;
 		*return_count = 0;
 		return NT_STATUS_OK;
 	}
@@ -2529,7 +2529,7 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	 * hostnames -> IP address. This is dns_addrs.
 	 *
 	 * Finally we will merge these two arrays to create the
-	 * return ip_service array.
+	 * return sockaddr_storage array.
 	 */
 
 	/* First count the sizes of each array. */
@@ -2639,9 +2639,9 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	}
 
 	/*
-	 * Combine the two sockaddr_storage arrays into a MALLOC'ed
-	 * ipservice array return.
-	 */
+	 * Combine the two sockaddr_storage arrays into a talloc'ed
+	 * struct sockaddr_storage array return.
+         */
 
 	numaddrs = num_srv_addrs + num_dns_addrs;
 	/* Wrap check + bloody int conversion check :-(. */
@@ -2654,8 +2654,10 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
-	iplist = SMB_MALLOC_ARRAY(struct ip_service, numaddrs);
-	if (iplist == NULL) {
+	ret_addrs = talloc_zero_array(ctx,
+				struct sockaddr_storage,
+				numaddrs);
+	if (ret_addrs == NULL) {
 		TALLOC_FREE(dcs);
 		TALLOC_FREE(srv_addrs);
 		TALLOC_FREE(dns_addrs);
@@ -2664,12 +2666,10 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	}
 
 	for (i = 0; i < num_srv_addrs; i++) {
-		iplist[i].ss = srv_addrs[i];
-		iplist[i].port = 0;
+		ret_addrs[i] = srv_addrs[i];
 	}
 	for (i = 0; i < num_dns_addrs; i++) {
-		iplist[num_srv_addrs+i].ss = dns_addrs[i];
-		iplist[i].port = 0;
+		ret_addrs[num_srv_addrs+i] = dns_addrs[i];
 	}
 
 	TALLOC_FREE(dcs);
@@ -2677,7 +2677,7 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	TALLOC_FREE(dns_addrs);
 	TALLOC_FREE(dns_lookup_names);
 
-	*return_iplist = iplist;
+	*return_addrs = ret_addrs;
 	*return_count = numaddrs;
 	return NT_STATUS_OK;
 }
@@ -2836,11 +2836,12 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "kdc")) {
 			/* deal with KDC_NAME_TYPE names here.
 			 * This will result in a SRV record lookup */
+			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_ads(talloc_tos(),
 					     name,
 					     KDC_NAME_TYPE,
 					     sitename,
-					     return_iplist,
+					     &ss_list,
 					     return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
@@ -2848,19 +2849,32 @@ NTSTATUS internal_resolve_name(const char *name,
 			/* Ensure we don't namecache
 			 * this with the KDC port. */
 			name_type = KDC_NAME_TYPE;
+			ok = convert_ss2service(return_iplist,
+						ss_list,
+						return_count);
+			if (!ok) {
+				status = NT_STATUS_NO_MEMORY;
+			}
 			goto done;
 		} else if(strequal( tok, "ads")) {
 			/* deal with 0x1c and 0x1b names here.
 			 * This will result in a SRV record lookup */
+			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_ads(talloc_tos(),
 					     name,
 					     name_type,
 					     sitename,
-					     return_iplist,
+					     &ss_list,
 					     return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
+			ok = convert_ss2service(return_iplist,
+						ss_list,
+						return_count);
+			if (!ok) {
+				status = NT_STATUS_NO_MEMORY;
+			}
 			goto done;
 		} else if (strequal(tok, "lmhosts")) {
 			struct sockaddr_storage *ss_list = NULL;
-- 
2.20.1


From f095cad5543cde98d700b4e1c84e4544565f6ddb Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 20:40:02 -0700
Subject: [PATCH 45/62] s3: libsmb: Now all resolution functions return a
 ss_list on success, we only need one local variable for this.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 7 +------
 1 file changed, 1 insertion(+), 6 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 7d6546347a6..5a25df56e18 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2736,6 +2736,7 @@ NTSTATUS internal_resolve_name(const char *name,
 	NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
 	int i;
 	bool ok;
+	struct sockaddr_storage *ss_list = NULL;
 	TALLOC_CTX *frame = NULL;
 
 	*return_iplist = NULL;
@@ -2816,7 +2817,6 @@ NTSTATUS internal_resolve_name(const char *name,
 		tok = resolve_order[i];
 
 		if((strequal(tok, "host") || strequal(tok, "hosts"))) {
-			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_hosts(talloc_tos(),
 					       name,
 					       name_type,
@@ -2836,7 +2836,6 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "kdc")) {
 			/* deal with KDC_NAME_TYPE names here.
 			 * This will result in a SRV record lookup */
-			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_ads(talloc_tos(),
 					     name,
 					     KDC_NAME_TYPE,
@@ -2859,7 +2858,6 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "ads")) {
 			/* deal with 0x1c and 0x1b names here.
 			 * This will result in a SRV record lookup */
-			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_ads(talloc_tos(),
 					     name,
 					     name_type,
@@ -2877,7 +2875,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			}
 			goto done;
 		} else if (strequal(tok, "lmhosts")) {
-			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_lmhosts_file_as_sockaddr(
 				talloc_tos(),
 				get_dyn_LMHOSTSFILE(),
@@ -2898,7 +2895,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			goto done;
 		} else if (strequal(tok, "wins")) {
 			/* don't resolve 1D via WINS */
-			struct sockaddr_storage *ss_list = NULL;
 			if (name_type == 0x1D) {
 				continue;
 			}
@@ -2919,7 +2915,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			}
 			goto done;
 		} else if (strequal(tok, "bcast")) {
-			struct sockaddr_storage *ss_list = NULL;
 			status = name_resolve_bcast(
 						talloc_tos(),
 						name,
-- 
2.20.1


From 60de921ecd5f09cc81b6353d8f84aaa3896b5ffd Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 20:52:58 -0700
Subject: [PATCH 46/62] s3: libsmb: Move all calls to convert_ss2service() to
 one place now all methods return a sockaddr_storage.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 50 ++++++--------------------------------
 1 file changed, 8 insertions(+), 42 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 5a25df56e18..6fab3d318e4 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2825,13 +2825,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			ok = convert_ss2service(return_iplist,
-						ss_list,
-						return_count);
-			if (!ok) {
-				status = NT_STATUS_NO_MEMORY;
-				goto fail;
-			}
 			goto done;
 		} else if(strequal( tok, "kdc")) {
 			/* deal with KDC_NAME_TYPE names here.
@@ -2848,12 +2841,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			/* Ensure we don't namecache
 			 * this with the KDC port. */
 			name_type = KDC_NAME_TYPE;
-			ok = convert_ss2service(return_iplist,
-						ss_list,
-						return_count);
-			if (!ok) {
-				status = NT_STATUS_NO_MEMORY;
-			}
 			goto done;
 		} else if(strequal( tok, "ads")) {
 			/* deal with 0x1c and 0x1b names here.
@@ -2867,12 +2854,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			ok = convert_ss2service(return_iplist,
-						ss_list,
-						return_count);
-			if (!ok) {
-				status = NT_STATUS_NO_MEMORY;
-			}
 			goto done;
 		} else if (strequal(tok, "lmhosts")) {
 			status = resolve_lmhosts_file_as_sockaddr(
@@ -2885,13 +2866,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			ok = convert_ss2service(return_iplist,
-						ss_list,
-						return_count);
-			if (!ok) {
-				status = NT_STATUS_NO_MEMORY;
-				goto fail;
-			}
 			goto done;
 		} else if (strequal(tok, "wins")) {
 			/* don't resolve 1D via WINS */
@@ -2906,13 +2880,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			ok = convert_ss2service(return_iplist,
-						ss_list,
-						return_count);
-			if (!ok) {
-				status = NT_STATUS_NO_MEMORY;
-				goto fail;
-			}
 			goto done;
 		} else if (strequal(tok, "bcast")) {
 			status = name_resolve_bcast(
@@ -2924,13 +2891,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			ok = convert_ss2service(return_iplist,
-						ss_list,
-						return_count);
-			if (!ok) {
-				status = NT_STATUS_NO_MEMORY;
-				goto fail;
-			}
 			goto done;
 		} else {
 			DBG_ERR("unknown name switch type %s\n",
@@ -2940,8 +2900,6 @@ NTSTATUS internal_resolve_name(const char *name,
 
 	/* All of the resolve_* functions above have returned false. */
 
-  fail:
-
 	TALLOC_FREE(frame);
 	SAFE_FREE(*return_iplist);
 	*return_count = 0;
@@ -2950,6 +2908,14 @@ NTSTATUS internal_resolve_name(const char *name,
 
   done:
 
+	ok = convert_ss2service(return_iplist, ss_list, return_count);
+	if (!ok) {
+		TALLOC_FREE(frame);
+		SAFE_FREE(*return_iplist);
+		*return_count = 0;
+		return NT_STATUS_NO_MEMORY;
+	}
+
 	/* Remove duplicate entries.  Some queries, notably #1c (domain
 	controllers) return the PDC in iplist[0] and then all domain
 	controllers including the PDC in iplist[1..n].  Iterating over
-- 
2.20.1


From 41b0856b16c8cd16904f97fcd6a602622a0f60ee Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 17 Jul 2020 14:21:09 -0700
Subject: [PATCH 47/62] lib: addns: Add code for asynchronously looking up A
 records.

Returns an array of struct sockaddr_storage.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 lib/addns/dnsquery.c | 200 +++++++++++++++++++++++++++++++++++++++++++
 lib/addns/dnsquery.h |  15 ++++
 2 files changed, 215 insertions(+)

diff --git a/lib/addns/dnsquery.c b/lib/addns/dnsquery.c
index 87ae97e3d0b..1b07f6ee347 100644
--- a/lib/addns/dnsquery.c
+++ b/lib/addns/dnsquery.c
@@ -369,6 +369,206 @@ fail:
 	return status;
 }
 
+/*********************************************************************
+ Async A record lookup.
+*********************************************************************/
+
+struct ads_dns_lookup_a_state {
+	uint8_t rcode;
+	size_t num_names;
+	char **hostnames;
+	struct sockaddr_storage *addrs;
+};
+
+static void ads_dns_lookup_a_done(struct tevent_req *subreq);
+
+struct tevent_req *ads_dns_lookup_a_send(TALLOC_CTX *mem_ctx,
+					 struct tevent_context *ev,
+					 const char *name)
+{
+	struct tevent_req *req = NULL, *subreq = NULL;
+	struct ads_dns_lookup_a_state *state = NULL;
+
+	req = tevent_req_create(mem_ctx, &state,
+				struct ads_dns_lookup_a_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	subreq = dns_lookup_send(
+		state,
+		ev,
+		NULL,
+		name,
+		DNS_QCLASS_IN,
+		DNS_QTYPE_A);
+
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, ev);
+	}
+	tevent_req_set_callback(subreq, ads_dns_lookup_a_done, req);
+	return req;
+}
+
+static void ads_dns_lookup_a_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct ads_dns_lookup_a_state *state = tevent_req_data(
+		req, struct ads_dns_lookup_a_state);
+	int ret;
+	struct dns_name_packet *reply = NULL;
+	uint16_t i;
+
+	ret = dns_lookup_recv(subreq, state, &reply);
+	TALLOC_FREE(subreq);
+	if (ret != 0) {
+		tevent_req_nterror(req, map_nt_error_from_unix_common(ret));
+		return;
+	}
+
+	state->rcode = (reply->operation & DNS_RCODE);
+	if (state->rcode != DNS_RCODE_OK) {
+		/* Don't bother looking for answers. */
+		tevent_req_done(req);
+		return;
+	}
+
+	/*
+	 * We don't care about CNAME answers here. We're
+	 * just wanting an async name -> IPv4 lookup.
+	 */
+	for (i = 0; i < reply->ancount; i++) {
+		if (reply->answers[i].rr_type == DNS_QTYPE_A) {
+			state->num_names += 1;
+		}
+	}
+
+	state->hostnames = talloc_zero_array(state,
+					     char *,
+					     state->num_names);
+	if (tevent_req_nomem(state->hostnames, req)) {
+		return;
+	}
+	state->addrs = talloc_zero_array(state,
+					 struct sockaddr_storage,
+					 state->num_names);
+	if (tevent_req_nomem(state->addrs, req)) {
+		return;
+	}
+
+	state->num_names = 0;
+
+	for (i = 0; i < reply->ancount; i++) {
+		bool ok;
+		struct sockaddr_storage ss = {0};
+		struct dns_res_rec *an = &reply->answers[i];
+
+		if (an->rr_type != DNS_QTYPE_A) {
+			continue;
+		}
+		if (an->name == NULL) {
+			/* Can this happen? */
+			continue;
+		}
+		if (an->rdata.ipv4_record == NULL) {
+			/* Can this happen? */
+			continue;
+		}
+		ok = dns_res_rec_get_sockaddr(an,
+					      &ss);
+		if (!ok) {
+			continue;
+		}
+		if (is_zero_addr(&ss)) {
+			continue;
+		}
+		state->addrs[state->num_names]= ss;
+		state->hostnames[state->num_names] = talloc_strdup(
+							state->hostnames,
+							an->name);
+		if (tevent_req_nomem(state->hostnames[state->num_names], req)) {
+			return;
+		}
+		state->num_names += 1;
+	}
+
+	tevent_req_done(req);
+}
+
+NTSTATUS ads_dns_lookup_a_recv(struct tevent_req *req,
+			       TALLOC_CTX *mem_ctx,
+			       uint8_t *rcode_out,
+			       size_t *num_names_out,
+			       char ***hostnames_out,
+			       struct sockaddr_storage **addrs_out)
+{
+	struct ads_dns_lookup_a_state *state = tevent_req_data(
+		req, struct ads_dns_lookup_a_state);
+	NTSTATUS status;
+
+	if (tevent_req_is_nterror(req, &status)) {
+		return status;
+	}
+	if (rcode_out != NULL) {
+		/*
+		 * If we got no names, an upper layer may
+		 * want to print a debug message.
+		 */
+		*rcode_out = state->rcode;
+	}
+	if (hostnames_out != NULL) {
+		*hostnames_out = talloc_move(mem_ctx,
+					     &state->hostnames);
+	}
+	if (addrs_out != NULL) {
+		*addrs_out = talloc_move(mem_ctx,
+					 &state->addrs);
+	}
+	*num_names_out = state->num_names;
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+/*********************************************************************
+ Simple wrapper for a DNS A query
+*********************************************************************/
+
+NTSTATUS ads_dns_lookup_a(TALLOC_CTX *ctx,
+			  const char *name_in,
+			  size_t *num_names_out,
+			  char ***hostnames_out,
+			  struct sockaddr_storage **addrs_out)
+{
+	struct tevent_context *ev;
+	struct tevent_req *req;
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+
+	ev = samba_tevent_context_init(ctx);
+	if (ev == NULL) {
+		goto fail;
+	}
+	req = ads_dns_lookup_a_send(ev, ev, name_in);
+	if (req == NULL) {
+		goto fail;
+	}
+	if (!tevent_req_poll_ntstatus(req, ev, &status)) {
+		goto fail;
+	}
+	/*
+	 * Sychronous doesn't need to care about the rcode or
+	 * a copy of the name_in.
+	 */
+	status = ads_dns_lookup_a_recv(req,
+				       ctx,
+				       NULL,
+				       num_names_out,
+				       hostnames_out,
+				       addrs_out);
+fail:
+	TALLOC_FREE(ev);
+	return status;
+}
 
 /********************************************************************
  Query with optional sitename.
diff --git a/lib/addns/dnsquery.h b/lib/addns/dnsquery.h
index bb691f5d55a..229b2134ff7 100644
--- a/lib/addns/dnsquery.h
+++ b/lib/addns/dnsquery.h
@@ -48,6 +48,21 @@ NTSTATUS ads_dns_lookup_ns(TALLOC_CTX *ctx,
 				const char *dnsdomain,
 				struct dns_rr_ns **nslist,
 				int *numns);
+struct tevent_req *ads_dns_lookup_a_send(TALLOC_CTX *mem_ctx,
+				struct tevent_context *ev,
+				const char *name);
+NTSTATUS ads_dns_lookup_a_recv(struct tevent_req *req,
+				TALLOC_CTX *mem_ctx,
+				uint8_t *rcode_out,
+				size_t *num_names_out,
+				char ***hostnames_out,
+				struct sockaddr_storage **addrs_out);
+NTSTATUS ads_dns_lookup_a(TALLOC_CTX *ctx,
+			const char *name_in,
+			size_t *num_names_out,
+			char ***hostnames_out,
+			struct sockaddr_storage **addrs_out);
+
 NTSTATUS ads_dns_query_dcs(TALLOC_CTX *ctx,
 			   const char *realm,
 			   const char *sitename,
-- 
2.20.1


From e2a1f350b99f97205a51057455fd6d3825d4f6d4 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 17 Jul 2020 14:30:02 -0700
Subject: [PATCH 48/62] lib: addns: Add code for asynchronously looking up AAAA
 records.

Returns an array of struct sockaddr_storage.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 lib/addns/dnsquery.c | 203 +++++++++++++++++++++++++++++++++++++++++++
 lib/addns/dnsquery.h |  16 ++++
 2 files changed, 219 insertions(+)

diff --git a/lib/addns/dnsquery.c b/lib/addns/dnsquery.c
index 1b07f6ee347..7795eea53f1 100644
--- a/lib/addns/dnsquery.c
+++ b/lib/addns/dnsquery.c
@@ -570,6 +570,209 @@ fail:
 	return status;
 }
 
+#if defined(HAVE_IPV6)
+/*********************************************************************
+ Async AAAA record lookup.
+*********************************************************************/
+
+struct ads_dns_lookup_aaaa_state {
+	uint8_t rcode;
+	size_t num_names;
+	char **hostnames;
+	struct sockaddr_storage *addrs;
+};
+
+static void ads_dns_lookup_aaaa_done(struct tevent_req *subreq);
+
+struct tevent_req *ads_dns_lookup_aaaa_send(TALLOC_CTX *mem_ctx,
+					    struct tevent_context *ev,
+					    const char *name)
+{
+	struct tevent_req *req, *subreq = NULL;
+	struct ads_dns_lookup_aaaa_state *state = NULL;
+
+	req = tevent_req_create(mem_ctx, &state,
+				struct ads_dns_lookup_aaaa_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	subreq = dns_lookup_send(
+		state,
+		ev,
+		NULL,
+		name,
+		DNS_QCLASS_IN,
+		DNS_QTYPE_AAAA);
+
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, ev);
+	}
+	tevent_req_set_callback(subreq, ads_dns_lookup_aaaa_done, req);
+	return req;
+}
+
+static void ads_dns_lookup_aaaa_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct ads_dns_lookup_aaaa_state *state = tevent_req_data(
+		req, struct ads_dns_lookup_aaaa_state);
+	int ret;
+	struct dns_name_packet *reply = NULL;
+	uint16_t i;
+
+	ret = dns_lookup_recv(subreq, state, &reply);
+	TALLOC_FREE(subreq);
+	if (ret != 0) {
+		tevent_req_nterror(req, map_nt_error_from_unix_common(ret));
+		return;
+	}
+
+	state->rcode = (reply->operation & DNS_RCODE);
+	if (state->rcode != DNS_RCODE_OK) {
+		/* Don't bother looking for answers. */
+		tevent_req_done(req);
+		return;
+	}
+
+	/*
+	 * We don't care about CNAME answers here. We're
+	 * just wanting an async name -> IPv6 lookup.
+	 */
+	for (i = 0; i < reply->ancount; i++) {
+		if (reply->answers[i].rr_type == DNS_QTYPE_AAAA) {
+			state->num_names += 1;
+		}
+	}
+
+	state->hostnames = talloc_zero_array(state,
+					     char *,
+					     state->num_names);
+	if (tevent_req_nomem(state->hostnames, req)) {
+		return;
+	}
+	state->addrs = talloc_zero_array(state,
+					 struct sockaddr_storage,
+					 state->num_names);
+	if (tevent_req_nomem(state->addrs, req)) {
+		return;
+	}
+
+	state->num_names = 0;
+
+	for (i = 0; i < reply->ancount; i++) {
+		bool ok;
+		struct sockaddr_storage ss = {0};
+		struct dns_res_rec *an = &reply->answers[i];
+
+		if (an->rr_type != DNS_QTYPE_AAAA) {
+			continue;
+		}
+		if (an->name == NULL) {
+			/* Can this happen? */
+			continue;
+		}
+		if (an->rdata.ipv6_record == NULL) {
+			/* Can this happen? */
+			continue;
+		}
+		ok = dns_res_rec_get_sockaddr(an,
+					      &ss);
+		if (!ok) {
+			continue;
+		}
+		if (is_zero_addr(&ss)) {
+			continue;
+		}
+		state->addrs[state->num_names] = ss;
+		state->hostnames[state->num_names] = talloc_strdup(
+							state->hostnames,
+							an->name);
+		if (tevent_req_nomem(state->hostnames[state->num_names], req)) {
+			return;
+		}
+		state->num_names += 1;
+	}
+
+	tevent_req_done(req);
+}
+
+NTSTATUS ads_dns_lookup_aaaa_recv(struct tevent_req *req,
+				  TALLOC_CTX *mem_ctx,
+				  uint8_t *rcode_out,
+				  size_t *num_names_out,
+				  char ***hostnames_out,
+				  struct sockaddr_storage **addrs_out)
+{
+	struct ads_dns_lookup_aaaa_state *state = tevent_req_data(
+		req, struct ads_dns_lookup_aaaa_state);
+	NTSTATUS status;
+
+	if (tevent_req_is_nterror(req, &status)) {
+		return status;
+	}
+	if (rcode_out != NULL) {
+		/*
+		 * If we got no names, an upper layer may
+		 * want to print a debug message.
+		 */
+		*rcode_out = state->rcode;
+	}
+	if (hostnames_out != NULL) {
+		*hostnames_out = talloc_move(mem_ctx,
+					     &state->hostnames);
+	}
+	if (addrs_out != NULL) {
+		*addrs_out = talloc_move(mem_ctx,
+					 &state->addrs);
+	}
+	*num_names_out = state->num_names;
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+/*********************************************************************
+ Simple wrapper for a DNS AAAA query
+*********************************************************************/
+
+NTSTATUS ads_dns_lookup_aaaa(TALLOC_CTX *ctx,
+			     const char *name_in,
+			     size_t *num_names_out,
+			     char ***hostnames_out,
+			     struct sockaddr_storage **addrs_out)
+{
+	struct tevent_context *ev = NULL;
+	struct tevent_req *req = NULL;
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+
+	ev = samba_tevent_context_init(ctx);
+	if (ev == NULL) {
+		goto fail;
+	}
+	req = ads_dns_lookup_aaaa_send(ev, ev, name_in);
+	if (req == NULL) {
+		goto fail;
+	}
+	if (!tevent_req_poll_ntstatus(req, ev, &status)) {
+		goto fail;
+	}
+	/*
+	 * Sychronous doesn't need to care about the rcode or
+	 * a copy of the name_in.
+	 */
+	status = ads_dns_lookup_aaaa_recv(req,
+					  ctx,
+					  NULL,
+					  num_names_out,
+					  hostnames_out,
+					  addrs_out);
+fail:
+	TALLOC_FREE(ev);
+	return status;
+}
+#endif
+
 /********************************************************************
  Query with optional sitename.
 ********************************************************************/
diff --git a/lib/addns/dnsquery.h b/lib/addns/dnsquery.h
index 229b2134ff7..c7d397172f0 100644
--- a/lib/addns/dnsquery.h
+++ b/lib/addns/dnsquery.h
@@ -62,6 +62,22 @@ NTSTATUS ads_dns_lookup_a(TALLOC_CTX *ctx,
 			size_t *num_names_out,
 			char ***hostnames_out,
 			struct sockaddr_storage **addrs_out);
+#if defined(HAVE_IPV6)
+struct tevent_req *ads_dns_lookup_aaaa_send(TALLOC_CTX *mem_ctx,
+				struct tevent_context *ev,
+				const char *name);
+NTSTATUS ads_dns_lookup_aaaa_recv(struct tevent_req *req,
+				TALLOC_CTX *mem_ctx,
+				uint8_t *rcode_out,
+				size_t *num_names_out,
+				char ***hostnames_out,
+				struct sockaddr_storage **addrs_out);
+NTSTATUS ads_dns_lookup_aaaa(TALLOC_CTX *ctx,
+			const char *name_in,
+			size_t *num_names_out,
+			char ***hostnames_out,
+			struct sockaddr_storage **addrs_out);
+#endif
 
 NTSTATUS ads_dns_query_dcs(TALLOC_CTX *ctx,
 			   const char *realm,
-- 
2.20.1


From b0826162895e795e17e762c2e0216e9eadb44ae7 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 17 Jul 2020 14:45:45 -0700
Subject: [PATCH 49/62] s3: net: Add new 'net ads dns async <name>' command.

Will test the async DNS lookups in the next commit.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/utils/net_ads.c | 82 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 82 insertions(+)

diff --git a/source3/utils/net_ads.c b/source3/utils/net_ads.c
index 19ac9e4533f..8cbfb59f676 100644
--- a/source3/utils/net_ads.c
+++ b/source3/utils/net_ads.c
@@ -2211,6 +2211,80 @@ static int net_ads_dns_gethostbyname(struct net_context *c, int argc, const char
 	return 0;
 }
 
+static int net_ads_dns_async(struct net_context *c, int argc, const char **argv)
+{
+	size_t num_names = 0;
+	char **hostnames = NULL;
+	size_t i = 0;
+	struct sockaddr_storage *addrs = NULL;
+	NTSTATUS status;
+
+	if (argc != 1 || c->display_usage) {
+		d_printf(  "%s\n"
+			   "    %s\n"
+			   "    %s\n",
+			 _("Usage:"),
+			 _("net ads dns async <name>\n"),
+			 _("  Async look up hostname from the DNS server\n"
+			   "    hostname\tName to look up\n"));
+		return -1;
+	}
+
+	status = ads_dns_lookup_a(talloc_tos(),
+				  argv[0],
+				  &num_names,
+				  &hostnames,
+				  &addrs);
+	if (!NT_STATUS_IS_OK(status)) {
+		d_printf("Looking up A record for %s got error %s\n",
+			 argv[0],
+			 nt_errstr(status));
+		return -1;
+	}
+	d_printf("Async A record lookup - got %u names for %s\n",
+		 (unsigned int)num_names,
+		 argv[0]);
+	for (i = 0; i < num_names; i++) {
+		char addr_buf[INET6_ADDRSTRLEN];
+		print_sockaddr(addr_buf,
+			       sizeof(addr_buf),
+			       &addrs[i]);
+		d_printf("hostname[%u] = %s, IPv4addr = %s\n",
+			(unsigned int)i,
+			hostnames[i],
+			addr_buf);
+	}
+
+#if defined(HAVE_IPV6)
+	status = ads_dns_lookup_aaaa(talloc_tos(),
+				     argv[0],
+				     &num_names,
+				     &hostnames,
+				     &addrs);
+	if (!NT_STATUS_IS_OK(status)) {
+		d_printf("Looking up AAAA record for %s got error %s\n",
+			 argv[0],
+			 nt_errstr(status));
+		return -1;
+	}
+	d_printf("Async AAAA record lookup - got %u names for %s\n",
+		 (unsigned int)num_names,
+		 argv[0]);
+	for (i = 0; i < num_names; i++) {
+		char addr_buf[INET6_ADDRSTRLEN];
+		print_sockaddr(addr_buf,
+			       sizeof(addr_buf),
+			       &addrs[i]);
+		d_printf("hostname[%u] = %s, IPv6addr = %s\n",
+			(unsigned int)i,
+			hostnames[i],
+			addr_buf);
+	}
+#endif
+	return 0;
+}
+
+
 static int net_ads_dns(struct net_context *c, int argc, const char *argv[])
 {
 	struct functable func[] = {
@@ -2238,6 +2312,14 @@ static int net_ads_dns(struct net_context *c, int argc, const char *argv[])
 			N_("net ads dns gethostbyname\n"
 			   "    Look up host")
 		},
+		{
+			"async",
+			net_ads_dns_async,
+			NET_TRANSPORT_ADS,
+			N_("Look up host"),
+			N_("net ads dns async\n"
+			   "    Look up host using async DNS")
+		},
 		{NULL, NULL, 0, NULL, NULL}
 	};
 
-- 
2.20.1


From 700f146bdcb6729ca52e12d63499a5a516776bfd Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 5 Aug 2020 15:46:04 -0700
Subject: [PATCH 50/62] s4: tests: Add new async DNS unit test -
 samba4.blackbox.net_ads_dns_async(ad_member:local).

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source4/selftest/tests.py                    |  6 ++
 testprogs/blackbox/test_net_ads_dns_async.sh | 67 ++++++++++++++++++++
 2 files changed, 73 insertions(+)
 create mode 100755 testprogs/blackbox/test_net_ads_dns_async.sh

diff --git a/source4/selftest/tests.py b/source4/selftest/tests.py
index 73f273d0045..9a86291fb1a 100755
--- a/source4/selftest/tests.py
+++ b/source4/selftest/tests.py
@@ -500,6 +500,12 @@ plantestsuite("samba4.blackbox.client_etypes_all(ad_dc:client)", "ad_dc:client",
 plantestsuite("samba4.blackbox.client_etypes_legacy(ad_dc:client)", "ad_dc:client", [os.path.join(bbdir, "test_client_etypes.sh"), '$DC_SERVER', '$DC_USERNAME', '$DC_PASSWORD', '$PREFIX_ABS', 'legacy', '23'])
 plantestsuite("samba4.blackbox.client_etypes_strong(ad_dc:client)", "ad_dc:client", [os.path.join(bbdir, "test_client_etypes.sh"), '$DC_SERVER', '$DC_USERNAME', '$DC_PASSWORD', '$PREFIX_ABS', 'strong', '17_18'])
 plantestsuite("samba4.blackbox.net_ads_dns(ad_member:local)", "ad_member:local", [os.path.join(bbdir, "test_net_ads_dns.sh"), '$DC_SERVER', '$DC_USERNAME', '$DC_PASSWORD', '$REALM', '$USERNAME', '$PASSWORD'])
+plantestsuite("samba4.blackbox.net_ads_dns_async(ad_member:local)",
+        "ad_member:local",
+        [os.path.join(bbdir,
+            "test_net_ads_dns_async.sh"),
+            '$DC_SERVER',
+            '$REALM'])
 plantestsuite("samba4.blackbox.samba-tool_ntacl(ad_member:local)", "ad_member:local", [os.path.join(bbdir, "test_samba-tool_ntacl.sh"), '$PREFIX', '$DOMSID'])
 plantestsuite_loadlist("samba4.rpc.echo against NetBIOS alias", "ad_dc_ntvfs", [valgrindify(smbtorture4), "$LISTOPT", "$LOADLIST", 'ncacn_np:$NETBIOSALIAS', '-U$DOMAIN/$USERNAME%$PASSWORD', 'rpc.echo'])
 # json tests hook into ``chgdcpass'' to make them run in contributor CI on
diff --git a/testprogs/blackbox/test_net_ads_dns_async.sh b/testprogs/blackbox/test_net_ads_dns_async.sh
new file mode 100755
index 00000000000..f0bd0835b4d
--- /dev/null
+++ b/testprogs/blackbox/test_net_ads_dns_async.sh
@@ -0,0 +1,67 @@
+#!/bin/sh
+# Blackbox tests for net ads dns async
+# Copyright (C) 2020 Jeremy Allison <jra@samba.org>
+
+if [ $# -lt 2 ]; then
+cat <<EOF
+Usage: test_net_ads_dns_async.sh SERVER REALM
+EOF
+exit 1;
+fi
+
+SERVER=$1
+REALM=$2
+shift 2
+failed=0
+
+samba4bindir="$BINDIR"
+net_tool="$samba4bindir/net"
+
+. `dirname $0`/subunit.sh
+
+# Test looking up SERVER.REALM on server give the
+# same IP via async and non-async DNS.
+echo "Starting ..."
+
+test_async_dns() {
+	#
+	# Do the gethostbyname request. This just prints the IPv4 addr.
+	#
+	cmd_sync='$net_tool ads dns gethostbyname $SERVER $SERVER.$REALM'
+	eval echo "$cmd_sync"
+	ipv4_sync=$(eval $cmd_sync)
+	if [ -z "$ipv4_sync" ]; then
+		return 1
+	fi
+
+	#
+	# Do the async request. This prints out info like:
+	#
+	# Async A record lookup - got 1 names for addc.ADDOM.SAMBA.EXAMPLE.COM
+	# hostname[0] = addc.ADDOM.SAMBA.EXAMPLE.COM, IPv4addr = 10.53.57.30
+	# Async AAAA record lookup - got 1 names for addc.ADDOM.SAMBA.EXAMPLE.COM
+	# hostname[0] = addc.ADDOM.SAMBA.EXAMPLE.COM, IPv6addr = fd00::5357:5f1e
+	#
+	# So we must grep and sed to extract the matching IPv4 address
+	#
+	cmd_async='$net_tool ads dns async $SERVER.$REALM'
+	eval echo "$cmd_async"
+	out_async=$(eval $cmd_async)
+
+	# Drop everything but the IPv4 address.
+	ipv4_async=`echo "$out_async" | grep IPv4addr | sed -e 's/^.*IPv4addr = //'`
+
+	if [ -z "$ipv4_async" ]; then
+		return 1
+	fi
+	if [ "$ipv4_sync" != "$ipv4_async" ]; then
+		echo "DNS lookup mismatch. Sync $ipv4_sync, async $ipv4_async"
+		echo "DNS commands output. out1=$ipv4_sync, out2=$out_async"
+		return 1
+	fi
+	return 0
+}
+
+testit "Check async and non async DNS lookups match " test_async_dns || failed=`expr $failed + 1`
+
+exit $failed
-- 
2.20.1


From 349bda8c210281a5ee826a0a7c9aa0972cadd089 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Thu, 23 Jul 2020 13:10:12 -0700
Subject: [PATCH 51/62] s3: Parameters. Add 'async dns timeout' parameter.
 Default to 10. Minimum value 1.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Andreas Schneider <asn@samba.org>
---
 .../smbdotconf/tuning/asyncdnstimeout.xml     | 21 +++++++++++++++++++
 lib/param/loadparm.c                          |  3 +++
 source3/include/proto.h                       |  1 +
 source3/param/loadparm.c                      | 16 ++++++++++++++
 4 files changed, 41 insertions(+)
 create mode 100644 docs-xml/smbdotconf/tuning/asyncdnstimeout.xml

diff --git a/docs-xml/smbdotconf/tuning/asyncdnstimeout.xml b/docs-xml/smbdotconf/tuning/asyncdnstimeout.xml
new file mode 100644
index 00000000000..6c7ead2b2fd
--- /dev/null
+++ b/docs-xml/smbdotconf/tuning/asyncdnstimeout.xml
@@ -0,0 +1,21 @@
+<samba:parameter name="async dns timeout"
+                 context="G"
+                 type="integer"
+                 xmlns:samba="http://www.samba.org/samba/DTD/samba-doc">
+<description>
+    <para>The number of seconds the asynchronous DNS
+    resolver code in Samba will wait for responses.
+    Some of the Samba client library code uses internal
+    asynchronous DNS resolution for A and AAAA records
+    when trying to find Active Directory Domain controllers.
+    This value prevents this name resolution code from
+    waiting for DNS server timeouts.
+    </para>
+    <para>The minimum value of this parameter is clamped
+    at 1 second.
+    zero.</para>
+</description>
+
+<value type="default">10</value>
+<value type="example">20</value>
+</samba:parameter>
diff --git a/lib/param/loadparm.c b/lib/param/loadparm.c
index e0c6adec9c8..99bd209fc47 100644
--- a/lib/param/loadparm.c
+++ b/lib/param/loadparm.c
@@ -3032,6 +3032,9 @@ struct loadparm_context *loadparm_init(TALLOC_CTX *mem_ctx)
 	lpcfg_do_global_parameter(
 		lp_ctx, "ldap max search request size", "256000");
 
+	/* Async DNS query timeout in seconds. */
+	lpcfg_do_global_parameter(lp_ctx, "async dns timeout", "10");
+
 	for (i = 0; parm_table[i].label; i++) {
 		if (!(lp_ctx->flags[i] & FLAG_CMDLINE)) {
 			lp_ctx->flags[i] |= FLAG_DEFAULT;
diff --git a/source3/include/proto.h b/source3/include/proto.h
index 8562317553c..e9d43326914 100644
--- a/source3/include/proto.h
+++ b/source3/include/proto.h
@@ -869,6 +869,7 @@ char* lp_perfcount_module(TALLOC_CTX *ctx);
 void widelinks_warning(int snum);
 const char *lp_ncalrpc_dir(void);
 void _lp_set_server_role(int server_role);
+uint32_t lp_get_async_dns_timeout(void);
 
 /* The following definitions come from param/loadparm_ctx.c  */
 
diff --git a/source3/param/loadparm.c b/source3/param/loadparm.c
index 5ee6d33c7fc..67ac5774999 100644
--- a/source3/param/loadparm.c
+++ b/source3/param/loadparm.c
@@ -960,6 +960,9 @@ static void init_globals(struct loadparm_context *lp_ctx, bool reinit_globals)
 	Globals.ldap_max_authenticated_request_size = 16777216;
 	Globals.ldap_max_search_request_size = 256000;
 
+	/* Async DNS query timeout (in seconds). */
+	Globals.async_dns_timeout = 10;
+
 	/* Now put back the settings that were set with lp_set_cmdline() */
 	apply_lp_set_cmdline();
 }
@@ -4681,3 +4684,16 @@ unsigned int * get_flags(void)
 
 	return flags_list;
 }
+
+uint32_t lp_get_async_dns_timeout(void)
+{
+	uint32_t val = Globals.async_dns_timeout;
+	/*
+	 * Clamp minimum async dns timeout to 1 second
+	 * as per the man page.
+	 */
+	if (val < 1) {
+		val = 1;
+	}
+	return val;
+}
-- 
2.20.1


From e4b9841a3a78cb3ceb6b0dee8621ba2b841c1712 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Tue, 21 Jul 2020 12:34:02 -0700
Subject: [PATCH 52/62] s3: libsmb: Add dns_lookup_list_async() - not yet used.

Take a list of hostnames and does async A and AAAA (if
supported) lookups on them. Interface compatible with
dns_lookup_list() (with the addition of one extra
parameter returning the query name list, for use inside
dsgetdcname() internals later) and we'll replace it in the next
commit. Waits for lp_get_async_dns_timeout() seconds to complete.

Commented out as not yet used.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Andreas Schneider <asn@samba.org>
---
 source3/libsmb/namequery.c | 390 +++++++++++++++++++++++++++++++++++++
 1 file changed, 390 insertions(+)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 6fab3d318e4..487a8015d77 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -31,6 +31,7 @@
 #include "../libcli/nbt/libnbt.h"
 #include "libads/kerberos_proto.h"
 #include "lib/gencache.h"
+#include "librpc/gen_ndr/dns.h"
 
 /* nmbd.c sets this to True. */
 bool global_in_nmbd = False;
@@ -2270,6 +2271,395 @@ fail:
 	return status;
 }
 
+#if 0
+/********************************************************
+ Use ads_dns_lookup_[a|aaaa]_send() calls to look up a
+ list of names asynchronously.
+*********************************************************/
+
+struct dns_query_state {
+	/* Used to tell our parent we've completed. */
+	struct dns_lookup_list_async_state *p_async_state;
+	const char *query_name; /* For debugging only. */
+	size_t num_addrs;
+	struct sockaddr_storage *addrs;
+};
+
+struct dns_lookup_list_async_state {
+	bool timed_out;
+	size_t num_query_returns;
+	struct dns_query_state *queries;
+};
+
+/* Called on query timeout. */
+static void dns_lookup_send_timeout_handler(struct tevent_context *ev,
+					    struct tevent_timer *te,
+					    struct timeval t,
+					    void *private_data)
+{
+	bool *timed_out = (bool *)private_data;
+	*timed_out = true;
+}
+
+static void dns_lookup_list_a_done(struct tevent_req *req);
+#if defined(HAVE_IPV6)
+static void dns_lookup_list_aaaa_done(struct tevent_req *req);
+#endif
+
+static NTSTATUS dns_lookup_list_async(TALLOC_CTX *ctx,
+				      size_t num_dns_names,
+				      const char **dns_lookup_names,
+				      size_t *p_num_addrs,
+				      struct sockaddr_storage **pp_addrs,
+				      char ***pp_dns_names)
+{
+	struct dns_lookup_list_async_state *state = NULL;
+	struct tevent_context *ev = NULL;
+	struct tevent_req *req = NULL;
+	struct tevent_timer *timer = NULL;
+	size_t num_queries_sent = 0;
+	size_t queries_size = num_dns_names;
+	size_t i;
+	size_t num_addrs = 0;
+	struct sockaddr_storage *addr_out = NULL;
+	char **dns_names_ret = NULL;
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+
+	/* Nothing to do. */
+	if (num_dns_names == 0) {
+		*p_num_addrs = 0;
+		*pp_addrs = NULL;
+		if (pp_dns_names != NULL) {
+			*pp_dns_names = NULL;
+		}
+		return NT_STATUS_OK;
+	}
+
+	state = talloc_zero(ctx, struct dns_lookup_list_async_state);
+	if (state == NULL) {
+		goto fail;
+	}
+	ev = samba_tevent_context_init(ctx);
+	if (ev == NULL) {
+		goto fail;
+	}
+
+#if defined(HAVE_IPV6)
+	queries_size = 2 * num_dns_names;
+	/* Wrap protection. */
+	if (queries_size < num_dns_names) {
+		goto fail;
+	}
+#else
+	queries_size = num_dns_names;
+#endif
+
+	state->queries = talloc_zero_array(state,
+					   struct dns_query_state,
+					   queries_size);
+	if (state == NULL) {
+		goto fail;
+	}
+
+	/* Hit all the DNS servers with asnyc lookups for all the names. */
+	for (i = 0; i < num_dns_names; i++) {
+		DBG_INFO("async DNS lookup A record for %s\n",
+			dns_lookup_names[i]);
+
+		/* Setup the query state. */
+		state->queries[num_queries_sent].query_name =
+					dns_lookup_names[i];
+		state->queries[num_queries_sent].p_async_state = state;
+
+		req = ads_dns_lookup_a_send(ev, ev, dns_lookup_names[i]);
+		if (req == NULL) {
+			goto fail;
+		}
+		tevent_req_set_callback(req,
+				dns_lookup_list_a_done,
+				&state->queries[num_queries_sent]);
+		num_queries_sent++;
+
+#if defined(HAVE_IPV6)
+		/* If we're IPv6 capable ask for that too. */
+		state->queries[num_queries_sent].query_name =
+					dns_lookup_names[i];
+		state->queries[num_queries_sent].p_async_state = state;
+
+		DBG_INFO("async DNS lookup AAAA record for %s\n",
+			dns_lookup_names[i]);
+
+		req = ads_dns_lookup_aaaa_send(ev, ev, dns_lookup_names[i]);
+		if (req == NULL) {
+			goto fail;
+		}
+		tevent_req_set_callback(req,
+					dns_lookup_list_aaaa_done,
+					&state->queries[num_queries_sent]);
+		num_queries_sent++;
+#endif
+	}
+
+	/* We must always have a timeout. */
+	timer = tevent_add_timer(ev,
+				 ev,
+				 timeval_current_ofs(lp_get_async_dns_timeout(),
+						     0),
+				 dns_lookup_send_timeout_handler,
+				 &state->timed_out);
+	if (timer == NULL) {
+		goto fail;
+	}
+
+	/* Loop until timed out or got all replies. */
+	for(;;) {
+		int ret;
+
+		if (state->timed_out) {
+			break;
+		}
+		if (state->num_query_returns == num_queries_sent) {
+			break;
+		}
+		ret = tevent_loop_once(ev);
+		if (ret != 0) {
+			goto fail;
+		}
+	}
+
+	/* Count what we got back. */
+	for (i = 0; i < num_queries_sent; i++) {
+		struct dns_query_state *query = &state->queries[i];
+
+		/* Wrap check. */
+		if (num_addrs + query->num_addrs < num_addrs) {
+			goto fail;
+		}
+		num_addrs += query->num_addrs;
+	}
+
+	if (state->timed_out) {
+		DBG_INFO("async DNS lookup timed out after %zu entries "
+			"(not an error)\n",
+			num_addrs);
+	}
+
+	addr_out = talloc_zero_array(ctx,
+				     struct sockaddr_storage,
+				     num_addrs);
+	if (addr_out == NULL) {
+		goto fail;
+	}
+
+	/*
+	 * Did the caller want an array of names back
+	 * that match the IP addresses ? If we provide
+	 * this, dsgetdcname() internals can now use this
+	 * async lookup code also.
+	 */
+	if (pp_dns_names != NULL) {
+		dns_names_ret = talloc_zero_array(ctx,
+						  char *,
+						  num_addrs);
+		if (dns_names_ret == NULL) {
+			goto fail;
+		}
+	}
+
+	/* Copy what we got back. */
+	num_addrs = 0;
+	for (i = 0; i < num_queries_sent; i++) {
+		size_t j;
+		struct dns_query_state *query = &state->queries[i];
+
+		if (query->num_addrs == 0) {
+			continue;
+		}
+
+		if (dns_names_ret != NULL) {
+			/*
+			 * If caller wants a name array matched with
+			 * the addrs array, copy the same queried name for
+			 * each IP address returned.
+			 */
+			for (j = 0; j < query->num_addrs; j++) {
+				dns_names_ret[num_addrs + j] = talloc_strdup(
+						ctx,
+						query->query_name);
+				if (dns_names_ret[num_addrs + j] == NULL) {
+					goto fail;
+				}
+			}
+		}
+
+		for (j = 0; j < query->num_addrs; j++) {
+			addr_out[num_addrs] = query->addrs[j];
+		}
+		num_addrs += query->num_addrs;
+	}
+
+	*p_num_addrs = num_addrs;
+	*pp_addrs = addr_out;
+	if (pp_dns_names != NULL) {
+		*pp_dns_names = dns_names_ret;
+	}
+
+	status = NT_STATUS_OK;
+
+  fail:
+
+	TALLOC_FREE(state);
+	TALLOC_FREE(ev);
+	return status;
+}
+
+/*
+ Called when an A record lookup completes.
+*/
+
+static void dns_lookup_list_a_done(struct tevent_req *req)
+{
+	/*
+	 * Callback data is an element of a talloc'ed array,
+	 * not a talloc object in its own right. So use the
+	 * tevent_req_callback_data_void() void * cast function.
+	 */
+	struct dns_query_state *state = (struct dns_query_state *)
+				tevent_req_callback_data_void(req);
+	uint8_t rcode = 0;
+	size_t i;
+	char **hostnames_out = NULL;
+	struct sockaddr_storage *addrs = NULL;
+	size_t num_addrs = 0;
+	NTSTATUS status;
+
+	/* For good or ill, tell the parent we're finished. */
+	state->p_async_state->num_query_returns++;
+
+	status = ads_dns_lookup_a_recv(req,
+				       state->p_async_state,
+				       &rcode,
+				       &num_addrs,
+				       &hostnames_out,
+				       &addrs);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_INFO("async DNS A lookup for %s returned %s\n",
+			state->query_name,
+			nt_errstr(status));
+		return;
+	}
+
+	if (rcode != DNS_RCODE_OK) {
+		DBG_INFO("async DNS A lookup for %s returned DNS code %u\n",
+			state->query_name,
+			(unsigned int)rcode);
+		return;
+	}
+
+	if (num_addrs == 0) {
+		DBG_INFO("async DNS A lookup for %s returned 0 addresses.\n",
+			state->query_name);
+		return;
+	}
+
+	/* Copy data out. */
+	state->addrs = talloc_zero_array(state->p_async_state,
+					 struct sockaddr_storage,
+					 num_addrs);
+	if (state->addrs == NULL) {
+		return;
+	}
+
+	for (i = 0; i < num_addrs; i++) {
+		char addr[INET6_ADDRSTRLEN];
+		DBG_INFO("async DNS A lookup for %s [%zu] got %s -> %s\n",
+			state->query_name,
+			i,
+			hostnames_out[i],
+			print_sockaddr(addr,
+				sizeof(addr),
+				&addrs[i]));
+
+		state->addrs[i] = addrs[i];
+	}
+	state->num_addrs = num_addrs;
+}
+
+#if defined(HAVE_IPV6)
+/*
+ Called when an AAAA record lookup completes.
+*/
+
+static void dns_lookup_list_aaaa_done(struct tevent_req *req)
+{
+	/*
+	 * Callback data is an element of a talloc'ed array,
+	 * not a talloc object in its own right. So use the
+	 * tevent_req_callback_data_void() void * cast function.
+	 */
+	struct dns_query_state *state = (struct dns_query_state *)
+				tevent_req_callback_data_void(req);
+	uint8_t rcode = 0;
+	size_t i;
+	char **hostnames_out = NULL;
+	struct sockaddr_storage *addrs = NULL;
+	size_t num_addrs = 0;
+	NTSTATUS status;
+
+	/* For good or ill, tell the parent we're finished. */
+	state->p_async_state->num_query_returns++;
+
+	status = ads_dns_lookup_aaaa_recv(req,
+					  state->p_async_state,
+					  &rcode,
+					  &num_addrs,
+					  &hostnames_out,
+					  &addrs);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_INFO("async DNS AAAA lookup for %s returned %s\n",
+			state->query_name,
+			nt_errstr(status));
+		return;
+	}
+
+	if (rcode != DNS_RCODE_OK) {
+		DBG_INFO("async DNS AAAA lookup for %s returned DNS code %u\n",
+			state->query_name,
+			(unsigned int)rcode);
+		return;
+	}
+
+	if (num_addrs == 0) {
+		DBG_INFO("async DNS AAAA lookup for %s returned 0 addresses.\n",
+			state->query_name);
+		return;
+	}
+
+	/* Copy data out. */
+	state->addrs = talloc_zero_array(state->p_async_state,
+					 struct sockaddr_storage,
+					 num_addrs);
+	if (state->addrs == NULL) {
+		return;
+	}
+
+	for (i = 0; i < num_addrs; i++) {
+		char addr[INET6_ADDRSTRLEN];
+		DBG_INFO("async DNS AAAA lookup for %s [%zu] got %s -> %s\n",
+			state->query_name,
+			i,
+			hostnames_out[i],
+			print_sockaddr(addr,
+				sizeof(addr),
+				&addrs[i]));
+
+		state->addrs[i] = addrs[i];
+	}
+	state->num_addrs = num_addrs;
+}
+#endif
+#endif
+
 /********************************************************
  Resolve a list of DNS names to a list of IP addresses.
  As this is a DC / LDAP / KDC lookup any IP address will
-- 
2.20.1


From a53a1e343c0a09b97f19df6a5530b32b3393c3cd Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Tue, 21 Jul 2020 12:38:42 -0700
Subject: [PATCH 53/62] s3: libsmb: Use dns_lookup_list_async() instead of
 dns_lookup_list().

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 487a8015d77..c25f2de88d5 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2271,7 +2271,6 @@ fail:
 	return status;
 }
 
-#if 0
 /********************************************************
  Use ads_dns_lookup_[a|aaaa]_send() calls to look up a
  list of names asynchronously.
@@ -2658,8 +2657,8 @@ static void dns_lookup_list_aaaa_done(struct tevent_req *req)
 	state->num_addrs = num_addrs;
 }
 #endif
-#endif
 
+#if 0
 /********************************************************
  Resolve a list of DNS names to a list of IP addresses.
  As this is a DC / LDAP / KDC lookup any IP address will
@@ -2740,6 +2739,7 @@ static NTSTATUS dns_lookup_list(TALLOC_CTX *ctx,
 	*pp_addrs = ret_addrs;
 	return NT_STATUS_OK;
 }
+#endif
 
 /********************************************************
  Resolve via "hosts" method.
@@ -3014,11 +3014,12 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	}
 
 	/* Lookup the addresses on the dns_lookup_list. */
-	status = dns_lookup_list(ctx,
+	status = dns_lookup_list_async(ctx,
 				num_dns_names,
 				dns_lookup_names,
 				&num_dns_addrs,
-				&dns_addrs);
+				&dns_addrs,
+				NULL);
 
 	if (!NT_STATUS_IS_OK(status)) {
 		TALLOC_FREE(dcs);
-- 
2.20.1


From 9474172f7a287073242c0ba2c0a55e7030918be3 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 17 Aug 2020 21:50:13 -0700
Subject: [PATCH 54/62] s3: libsmb: Remove dns_lookup_list(). No longer used.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 83 --------------------------------------
 1 file changed, 83 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index c25f2de88d5..bb664ca8d0a 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2658,89 +2658,6 @@ static void dns_lookup_list_aaaa_done(struct tevent_req *req)
 }
 #endif
 
-#if 0
-/********************************************************
- Resolve a list of DNS names to a list of IP addresses.
- As this is a DC / LDAP / KDC lookup any IP address will
- do, the requested names don't have to match the returned
- IP address list.
-*********************************************************/
-
-static NTSTATUS dns_lookup_list(TALLOC_CTX *ctx,
-				size_t num_dns_names,
-				const char **dns_lookup_names,
-				size_t *p_num_addrs,
-				struct sockaddr_storage **pp_addrs)
-{
-	size_t total_num_addrs = 0;
-	size_t i;
-	struct sockaddr_storage *ret_addrs = NULL;
-
-	/* FIXME - make this asnyc using our async DNS code. */
-
-	for (i = 0; i < num_dns_names; i++ ) {
-		struct addrinfo *res = NULL;
-		struct addrinfo *p = NULL;
-		size_t num_addrs = 0;
-		bool ok = interpret_string_addr_internal(&res,
-					dns_lookup_names[i],
-					0);
-		if (!ok) {
-			continue;
-		}
-		/* Count the IP's returned from the lookup. */
-		for (p = res; p; p = p->ai_next) {
-			num_addrs++;
-		}
-
-		/* Wrap check. */
-		if (total_num_addrs + num_addrs < total_num_addrs) {
-			if (res) {
-				freeaddrinfo(res);
-			}
-			return NT_STATUS_INVALID_PARAMETER;
-		}
-		ret_addrs = talloc_realloc(ctx,
-					   ret_addrs,
-					   struct sockaddr_storage,
-					   total_num_addrs + num_addrs);
-		if (ret_addrs == NULL) {
-			if (res) {
-				freeaddrinfo(res);
-			}
-			return NT_STATUS_NO_MEMORY;
-		}
-
-		for (p = res; p; p = p->ai_next) {
-			char addr[INET6_ADDRSTRLEN];
-
-			memcpy(&ret_addrs[total_num_addrs],
-				p->ai_addr,
-				p->ai_addrlen);
-
-			if (is_zero_addr(&ret_addrs[total_num_addrs])) {
-				continue;
-			}
-
-			DBG_DEBUG("getaddrinfo name %s returned IP %s\n",
-				dns_lookup_names[i],
-				print_sockaddr(addr,
-					sizeof(addr),
-					&ret_addrs[total_num_addrs]));
-
-			total_num_addrs++;
-		}
-		if (res) {
-			freeaddrinfo(res);
-		}
-	}
-
-	*p_num_addrs = total_num_addrs;
-	*pp_addrs = ret_addrs;
-	return NT_STATUS_OK;
-}
-#endif
-
 /********************************************************
  Resolve via "hosts" method.
 *********************************************************/
-- 
2.20.1


From ee0cf4562bb6e062f5a2887a73fd5ea9912db55f Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Tue, 21 Jul 2020 14:56:47 -0700
Subject: [PATCH 55/62] s3: libsmb: Make dns_lookup_list_async() available to
 other Samba callers.

This allows the async DNS lookups to be re-used inside the dsgetdcname() internals
code as previously described.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 12 ++++++------
 source3/libsmb/namequery.h |  6 ++++++
 2 files changed, 12 insertions(+), 6 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index bb664ca8d0a..d6ef7dd5146 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2305,12 +2305,12 @@ static void dns_lookup_list_a_done(struct tevent_req *req);
 static void dns_lookup_list_aaaa_done(struct tevent_req *req);
 #endif
 
-static NTSTATUS dns_lookup_list_async(TALLOC_CTX *ctx,
-				      size_t num_dns_names,
-				      const char **dns_lookup_names,
-				      size_t *p_num_addrs,
-				      struct sockaddr_storage **pp_addrs,
-				      char ***pp_dns_names)
+NTSTATUS dns_lookup_list_async(TALLOC_CTX *ctx,
+			      size_t num_dns_names,
+			      const char **dns_lookup_names,
+			      size_t *p_num_addrs,
+			      struct sockaddr_storage **pp_addrs,
+			      char ***pp_dns_names)
 {
 	struct dns_lookup_list_async_state *state = NULL;
 	struct tevent_context *ev = NULL;
diff --git a/source3/libsmb/namequery.h b/source3/libsmb/namequery.h
index aedb043ac81..d6f5d216733 100644
--- a/source3/libsmb/namequery.h
+++ b/source3/libsmb/namequery.h
@@ -85,6 +85,12 @@ NTSTATUS resolve_wins(TALLOC_CTX *mem_ctx,
 		int name_type,
 		struct sockaddr_storage **return_iplist,
 		int *return_count);
+NTSTATUS dns_lookup_list_async(TALLOC_CTX *ctx,
+			       size_t num_dns_names,
+			       const char **dns_lookup_names,
+			       size_t *p_num_addrs,
+			       struct sockaddr_storage **pp_addrs,
+			       char ***pp_dns_names);
 NTSTATUS internal_resolve_name(const char *name,
 			        int name_type,
 				const char *sitename,
-- 
2.20.1


From ecb66d3dbd15ea1e5ab7acf0850ee67abf4458c8 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Tue, 21 Jul 2020 22:09:27 -0700
Subject: [PATCH 56/62] s3: libsmb: Make discover_dc_dns() use async DNS.

Change to call dns_lookup_list_async(). This is
doing the samba SRV lookup followed by A and AAAA
record host lookup as resolve_ads() does and so
benefits from the same changes to make it async.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/dsgetdcname.c | 223 ++++++++++++++++++++++++++++-------
 1 file changed, 178 insertions(+), 45 deletions(-)

diff --git a/source3/libsmb/dsgetdcname.c b/source3/libsmb/dsgetdcname.c
index 08477065f34..cdcefbece3f 100644
--- a/source3/libsmb/dsgetdcname.c
+++ b/source3/libsmb/dsgetdcname.c
@@ -504,14 +504,17 @@ static NTSTATUS discover_dc_dns(TALLOC_CTX *mem_ctx,
 				struct ip_service_name **returned_dclist,
 				int *return_count)
 {
-	int i;
-	size_t j;
+	size_t i;
 	NTSTATUS status;
 	struct dns_rr_srv *dcs = NULL;
 	int numdcs = 0;
-	int numaddrs = 0;
 	struct ip_service_name *dclist = NULL;
-	int count = 0;
+	size_t ret_count = 0;
+	size_t num_dns_lookups = 0;
+	const char **dns_lookups = NULL;
+	size_t num_lookups_ret = 0;
+	struct sockaddr_storage *dns_addrs_ret = NULL;
+	char **dns_lookups_ret = NULL;
 
 	if (flags & DS_PDC_REQUIRED) {
 		status = ads_dns_query_pdc(mem_ctx,
@@ -554,74 +557,204 @@ static NTSTATUS discover_dc_dns(TALLOC_CTX *mem_ctx,
 	}
 
 	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(dcs);
 		return status;
 	}
 
-	if (numdcs == 0) {
+	/* Wrap protect. */
+	if (numdcs < 0) {
+		TALLOC_FREE(dcs);
 		return NT_STATUS_DOMAIN_CONTROLLER_NOT_FOUND;
 	}
 
-	for (i=0;i<numdcs;i++) {
-		numaddrs += MAX(dcs[i].num_ips,1);
+	if (numdcs == 0) {
+		TALLOC_FREE(dcs);
+		return NT_STATUS_DOMAIN_CONTROLLER_NOT_FOUND;
 	}
 
+	/*
+	 * We're only returning one address per
+	 * DC name, so just allocate size numdcs.
+	 */
+
 	dclist = talloc_zero_array(mem_ctx,
 				   struct ip_service_name,
-				   numaddrs);
+				   numdcs);
 	if (!dclist) {
+		TALLOC_FREE(dcs);
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	/* now unroll the list of IP addresses */
-
-	*return_count = 0;
-	i = 0;
-	j = 0;
-
-	while ((i < numdcs) && (count < numaddrs)) {
-
-		struct ip_service_name *r = &dclist[count];
+	/*
+	 * First, copy the SRV record replies that
+	 * have IP addresses returned with them.
+	 */
+	ret_count = 0;
+	for (i = 0; i < numdcs; i++) {
+		size_t j;
+
+		if (dcs[i].num_ips == 0) {
+			/*
+			 * No addresses returned in the SRV
+			 * reply, we must look this up via
+			 * DNS.
+			 */
+			num_dns_lookups++;
+			continue;
+		}
 
-		r->hostname = dcs[i].hostname;
+		dclist[ret_count].hostname =
+			talloc_move(mem_ctx, &dcs[i].hostname);
+
+		/*
+		 * Pick the first IPv4 address,
+		 * if none pick the first address.
+		 *
+		 * This is different from the previous
+		 * code which picked a 'next ip' address
+		 * each time, incrementing an index.
+		 * Too complex to maintain :-(.
+		 */
+		for (j = 0; j < dcs[i].num_ips; j++) {
+			if (dcs[i].ss_s[j].ss_family == AF_INET) {
+				dclist[ret_count].ss = dcs[i].ss_s[j];
+				break;
+			}
+		}
+		if (j == dcs[i].num_ips) {
+			/* No IPv4- use the first IPv6 addr. */
+			dclist[ret_count].ss = dcs[i].ss_s[0];
+		}
+		ret_count++;
+	}
+
+	/*
+	 * Now, create an array of hostnames we
+	 * will asynchronously look up in DNS.
+	 */
+	dns_lookups = talloc_zero_array(mem_ctx,
+					const char *,
+					num_dns_lookups);
+	if (dns_lookups == NULL) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(dclist);
+		return NT_STATUS_NO_MEMORY;
+	}
 
-		/* If we don't have an IP list for a name, lookup it up */
+	num_dns_lookups = 0;
+	for (i = 0; i < numdcs; i++) {
+		if (dcs[i].num_ips != 0) {
+			/*
+			 * We already got an address
+			 * for this via SRV return.
+			 */
+			continue;
+		}
+		dns_lookups[num_dns_lookups] =
+			talloc_strdup(mem_ctx, dcs[i].hostname);
+		if (dns_lookups[num_dns_lookups] == NULL) {
+			TALLOC_FREE(dcs);
+			TALLOC_FREE(dclist);
+			TALLOC_FREE(dns_lookups);
+		}
+		num_dns_lookups++;
+	}
 
-		if (!dcs[i].ss_s) {
-			interpret_string_addr_prefer_ipv4(&r->ss,
-						dcs[i].hostname, 0);
-			i++;
-			j = 0;
-		} else {
-			/* use the IP addresses from the SRV response */
+	status = dns_lookup_list_async(mem_ctx,
+				       num_dns_lookups,
+				       dns_lookups,
+				       &num_lookups_ret,
+				       &dns_addrs_ret,
+				       &dns_lookups_ret);
+	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(dclist);
+		TALLOC_FREE(dns_lookups);
+		return status;
+	}
 
-			if (j >= dcs[i].num_ips) {
-				i++;
-				j = 0;
+	/*
+	 * Remember, if we timed out or some
+	 * addresses didn't look up then
+	 * num_dns_lookups > num_lookups_ret,
+	 * so there isn't a one to one correspondence.
+	 *
+	 * The order of the requests is preserved
+	 * in the replies, but there may be requests
+	 * for which there are no replies if we
+	 * timed out.
+	 *
+	 * For example this means for looking up
+	 * names:
+	 *     NAME1
+	 *     NAME2
+	 *     NAME3
+	 *
+	 * The replies might look like:
+	 *     NAME1 -> IPv4
+	 *     NAME1 -> IPv4
+	 *     NAME1 -> IPv6
+	 *     NAME1 -> IPv6
+	 *     NAME3 -> IPv6
+	 *
+	 * But they will never be in the order:
+	 *
+	 *     NAME2
+	 *     NAME3
+	 *     NAME1
+	 *
+	 * Also in dns_lookup_list_async()
+	 * we arrange the requests/replies in
+	 * the order IPv4 followed by IPv6, so in
+	 * the replies, we can always pick the first
+	 * reply - we know it will be IPv4 if there
+	 * is an IPv4 for that name.
+	 *
+	 * Here ret_count is the index into the
+	 * next entry in dclist we must fill (may
+	 * be zero).
+	 */
+
+	for (i = 0; i < num_lookups_ret; i++) {
+		dclist[ret_count].hostname =
+			talloc_move(mem_ctx, &dns_lookups_ret[i]);
+		dclist[ret_count].ss = dns_addrs_ret[i];
+		/*
+		 * Is this a duplicate name return.
+		 * Remember we can look up both A and
+		 * AAAA records which can return multiple
+		 * addresses and the order of names
+		 * is preserved.
+		 */
+		if (ret_count > 0) {
+			if (strcmp(dclist[ret_count-1].hostname,
+				   dclist[ret_count].hostname) == 0) {
+				/*
+				 * Same name. Keep the first address
+				 * which is IPv4 by preference.
+				 */
 				continue;
 			}
-
-			r->ss = dcs[i].ss_s[j];
-			j++;
 		}
+		ret_count++;
 
-		/* make sure it is a valid IP.  I considered checking the
-		 * negative connection cache, but this is the wrong place for
-		 * it.  Maybe only as a hack. After think about it, if all of
-		 * the IP addresses returned from DNS are dead, what hope does a
-		 * netbios name lookup have?  The standard reason for falling
-		 * back to netbios lookups is that our DNS server doesn't know
-		 * anything about the DC's   -- jerry */
-
-		if (!is_zero_addr(&r->ss)) {
-			count++;
-			continue;
+		if (ret_count == numdcs) {
+			/* We've filled the return array. */
+			break;
 		}
 	}
 
 	*returned_dclist = dclist;
-	*return_count = count;
+	*return_count = (int)ret_count;
+
+	if (*return_count < 0) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(dclist);
+		TALLOC_FREE(dns_lookups);
+		return NT_STATUS_INTERNAL_ERROR;
+	}
 
-	if (count > 0) {
+	if (ret_count > 0) {
 		return NT_STATUS_OK;
 	}
 
-- 
2.20.1


From ff5ede32982ec4385874f6a7c7e9dd58ac8852e4 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 7 Aug 2020 20:18:50 -0700
Subject: [PATCH 57/62] s3: libads: Add utility function ads_zero_ldap().

When initializing or re-initializing the ldap part of the ADS_STRUCT,
we should call this to ensure that ads->ldap.ss is correctly recognized
as a zero IPaddr by is_zero_addr(). It zeros out the ads->ldap but
then adds zero_sockaddr() to initialize as AF_INET. Otherwise it's
left by accident as AF_UNSPEC (0).

Not yet used.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libads/ads_proto.h |  1 +
 source3/libads/ldap.c      | 19 +++++++++++++++++++
 2 files changed, 20 insertions(+)

diff --git a/source3/libads/ads_proto.h b/source3/libads/ads_proto.h
index 495ef5d3325..9c21f5470c5 100644
--- a/source3/libads/ads_proto.h
+++ b/source3/libads/ads_proto.h
@@ -81,6 +81,7 @@ bool ads_sitename_match(ADS_STRUCT *ads);
 bool ads_closest_dc(ADS_STRUCT *ads);
 ADS_STATUS ads_connect(ADS_STRUCT *ads);
 ADS_STATUS ads_connect_user_creds(ADS_STRUCT *ads);
+void ads_zero_ldap(ADS_STRUCT *ads);
 void ads_disconnect(ADS_STRUCT *ads);
 ADS_STATUS ads_do_search_all_fn(ADS_STRUCT *ads, const char *bind_path,
 				int scope, const char *expr, const char **attrs,
diff --git a/source3/libads/ldap.c b/source3/libads/ldap.c
index 8ad76ed0ae9..7e4265bb01f 100644
--- a/source3/libads/ldap.c
+++ b/source3/libads/ldap.c
@@ -738,6 +738,25 @@ ADS_STATUS ads_connect_user_creds(ADS_STRUCT *ads)
 	return ads_connect(ads);
 }
 
+/**
+ * Zero out the internal ads->ldap struct and initialize the address to zero IP.
+ * @param ads Pointer to an existing ADS_STRUCT
+ *
+ * Sets the ads->ldap.ss to a valid
+ * zero ip address that can be detected by
+ * our is_zero_addr() function. Otherwise
+ * it is left as AF_UNSPEC (0).
+ **/
+void ads_zero_ldap(ADS_STRUCT *ads)
+{
+	ZERO_STRUCT(ads->ldap);
+	/*
+	 * Initialize the sockaddr_storage so we can use
+	 * sockaddr test functions against it.
+	 */
+	zero_sockaddr(&ads->ldap.ss);
+}
+
 /**
  * Disconnect the LDAP server
  * @param ads Pointer to an existing ADS_STRUCT
-- 
2.20.1


From e9d633fe85594c14d0be2f22cd674aae019d79d6 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 7 Aug 2020 20:22:50 -0700
Subject: [PATCH 58/62] s3: libads: Where we implicitly zero out ads->ldap in
 ads_init() or ads_destroy() ensure we call ads_zero_ldap() after.

For ads_destroy(), this has a mode where the memory is not destroyed
but is being re-initialized. Horrid, but that's the way it works right
now.

This clears out the memory, but also leaves ads->ldap as a valid (zero) IPaddr.
Otherwise it's left by accident as AF_UNSPEC (0).

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libads/ads_struct.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/source3/libads/ads_struct.c b/source3/libads/ads_struct.c
index 043a1b21247..accd8900c83 100644
--- a/source3/libads/ads_struct.c
+++ b/source3/libads/ads_struct.c
@@ -140,6 +140,9 @@ ADS_STRUCT *ads_init(const char *realm,
 
 	ads = SMB_XMALLOC_P(ADS_STRUCT);
 	ZERO_STRUCTP(ads);
+#ifdef HAVE_LDAP
+	ads_zero_ldap(ads);
+#endif
 
 	ads->server.realm = realm? SMB_STRDUP(realm) : NULL;
 	ads->server.workgroup = workgroup ? SMB_STRDUP(workgroup) : NULL;
@@ -218,6 +221,9 @@ void ads_destroy(ADS_STRUCT **ads)
 		SAFE_FREE((*ads)->config.config_path);
 
 		ZERO_STRUCTP(*ads);
+#ifdef HAVE_LDAP
+		ads_zero_ldap(*ads);
+#endif
 
 		if ( is_mine )
 			SAFE_FREE(*ads);
-- 
2.20.1


From 8cd3a0b5aa99f38299e7860445141a26e5931aab Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 7 Aug 2020 20:24:07 -0700
Subject: [PATCH 59/62] s3: libads: In ads_connect(), and ads_disconnect(),
 replace ZERO_STRUCT(ads->ldap) with calls to ads_zero_ldap(ads)

This clears out the memory, but also leaves ads->ldap as a valid (zero) IPaddr.
Otherwise it's left by accident as AF_UNSPEC (0).

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libads/ldap.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/source3/libads/ldap.c b/source3/libads/ldap.c
index 7e4265bb01f..09cfdf7a45e 100644
--- a/source3/libads/ldap.c
+++ b/source3/libads/ldap.c
@@ -577,7 +577,7 @@ ADS_STATUS ads_connect(ADS_STRUCT *ads)
 	NTSTATUS ntstatus;
 	char addr[INET6_ADDRSTRLEN];
 
-	ZERO_STRUCT(ads->ldap);
+	ads_zero_ldap(ads);
 	ZERO_STRUCT(ads->ldap_wrap_data);
 	ads->ldap.last_attempt	= time_mono(NULL);
 	ads->ldap_wrap_data.wrap_type	= ADS_SASLWRAP_TYPE_PLAIN;
@@ -774,7 +774,7 @@ void ads_disconnect(ADS_STRUCT *ads)
 	if (ads->ldap_wrap_data.mem_ctx) {
 		talloc_free(ads->ldap_wrap_data.mem_ctx);
 	}
-	ZERO_STRUCT(ads->ldap);
+	ads_zero_ldap(ads);
 	ZERO_STRUCT(ads->ldap_wrap_data);
 }
 
-- 
2.20.1


From f6148b142d355006c95227a79ff0d1063a326bef Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 22 Jul 2020 15:35:43 -0700
Subject: [PATCH 60/62] s3: libads: ads_connect can be passed in an ADS_STRUCT
 with an existing IP address.

ads_connect can be passed in a reused ADS_STRUCT
with an existing ads->ldap.ss IP address that
is stored by going through ads_find_dc()
if ads->server.ldap_server was NULL.

If ads->server.ldap_server is still NULL but
the target address isn't a zero ip address,
then store it off before zeroing out ads->ldap
so we don't keep doing multiple calls to
ads_find_dc() in the reuse case.

If a caller wants a clean ADS_STRUCT they
will re-initialize by calling ads_init(), or
call ads_destroy() both of which ensures
ads->ldap.ss is a correctly zero'ed out IP address
by using ads_zero_ldap().

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libads/ldap.c | 38 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 38 insertions(+)

diff --git a/source3/libads/ldap.c b/source3/libads/ldap.c
index 09cfdf7a45e..dd5c36d124b 100644
--- a/source3/libads/ldap.c
+++ b/source3/libads/ldap.c
@@ -576,6 +576,30 @@ ADS_STATUS ads_connect(ADS_STRUCT *ads)
 	ADS_STATUS status;
 	NTSTATUS ntstatus;
 	char addr[INET6_ADDRSTRLEN];
+	struct sockaddr_storage existing_ss = {0};
+
+	/*
+	 * ads_connect can be passed in a reused ADS_STRUCT
+	 * with an existing non-zero ads->ldap.ss IP address
+	 * that was stored by going through ads_find_dc()
+	 * if ads->server.ldap_server was NULL.
+	 *
+	 * If ads->server.ldap_server is still NULL but
+	 * the target address isn't the zero address, then
+	 * store that address off off before zeroing out
+	 * ads->ldap so we don't keep doing multiple calls
+	 * to ads_find_dc() in the reuse case.
+	 *
+	 * If a caller wants a clean ADS_STRUCT they
+	 * will re-initialize by calling ads_init(), or
+	 * call ads_destroy() both of which ensures
+	 * ads->ldap.ss is a properly zero'ed out valid IP
+	 * address.
+	 */
+	if (ads->server.ldap_server == NULL && !is_zero_addr(&ads->ldap.ss)) {
+		/* Save off the address we previously found by ads_find_dc(). */
+		existing_ss = ads->ldap.ss;
+	}
 
 	ads_zero_ldap(ads);
 	ZERO_STRUCT(ads->ldap_wrap_data);
@@ -622,6 +646,20 @@ ADS_STATUS ads_connect(ADS_STRUCT *ads)
 		}
 	}
 
+	if (!is_zero_addr(&existing_ss)) {
+		/* We saved off who we should talk to. */
+		bool ok = ads_try_connect(ads,
+					  ads->server.gc,
+					  &existing_ss);
+		if (ok) {
+			goto got_connection;
+		}
+		/*
+		 * Keep trying to find a server and fall through
+		 * into ads_find_dc() again.
+		 */
+	}
+
 	ntstatus = ads_find_dc(ads);
 	if (NT_STATUS_IS_OK(ntstatus)) {
 		goto got_connection;
-- 
2.20.1


From b34d5e5b0d41a3954f56e74cd97eac90ab387a43 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 22 Jul 2020 19:00:52 -0700
Subject: [PATCH 61/62] s3: libads: Don't re-do DNS lookups in
 ads_current_time() if not needed.

ADS_STRUCT may be being reused after a
DC lookup from ads_find_dc(), so ads->ldap.ss may already have a
good address (even if ads->server.ldap_server == NULL).
Only re-initialize the ADS_STRUCT and redo the ads_find_fc()
DNS lookups if we have to.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libads/ldap.c | 26 +++++++++++++++++++++-----
 1 file changed, 21 insertions(+), 5 deletions(-)

diff --git a/source3/libads/ldap.c b/source3/libads/ldap.c
index dd5c36d124b..0e6c639b37d 100644
--- a/source3/libads/ldap.c
+++ b/source3/libads/ldap.c
@@ -3255,11 +3255,27 @@ ADS_STATUS ads_current_time(ADS_STRUCT *ads)
         /* establish a new ldap tcp session if necessary */
 
 	if ( !ads->ldap.ld ) {
-		if ( (ads_s = ads_init( ads->server.realm, ads->server.workgroup, 
-			ads->server.ldap_server, ADS_SASL_PLAIN )) == NULL )
-		{
-			status = ADS_ERROR(LDAP_NO_MEMORY);
-			goto done;
+		/*
+		 * ADS_STRUCT may be being reused after a
+		 * DC lookup, so ads->ldap.ss may already have a
+		 * good address. If not, re-initialize the passed-in
+		 * ADS_STRUCT with the given server.XXXX parameters.
+		 *
+		 * Note that this doesn't depend on
+		 * ads->server.ldap_server != NULL,
+		 * as the case where ads->server.ldap_server==NULL and
+		 * ads->ldap.ss != zero_address is precisely the DC
+		 * lookup case where ads->ldap.ss was found by going
+		 * through ads_find_dc() again we want to avoid repeating.
+		 */
+		if (is_zero_addr(&ads->ldap.ss)) {
+			if ((ads_s = ads_init(ads->server.realm,
+					ads->server.workgroup,
+					ads->server.ldap_server,
+					ADS_SASL_PLAIN )) == NULL ) {
+				status = ADS_ERROR(LDAP_NO_MEMORY);
+				goto done;
+			}
 		}
 		ads_s->auth.flags = ADS_AUTH_ANON_BIND;
 		status = ads_connect( ads_s );
-- 
2.20.1


From 084ca0619a9ef14aafa87c377367cbc33a046dfe Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 22 Jul 2020 19:03:23 -0700
Subject: [PATCH 62/62] s3: libads: Don't re-do DNS lookups in
 ads_domain_func_level() if not needed.

ADS_STRUCT may be being reused after a
DC lookup from ads_find_dc(), so ads->ldap.ss may already have a
good address (even if ads->server.ldap_server == NULL).
Only re-initialize the ADS_STRUCT and redo the ads_find_fc()
DNS lookups if we have to.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libads/ldap.c | 26 +++++++++++++++++++++-----
 1 file changed, 21 insertions(+), 5 deletions(-)

diff --git a/source3/libads/ldap.c b/source3/libads/ldap.c
index 0e6c639b37d..d224ffc9eb0 100644
--- a/source3/libads/ldap.c
+++ b/source3/libads/ldap.c
@@ -3333,11 +3333,27 @@ ADS_STATUS ads_domain_func_level(ADS_STRUCT *ads, uint32_t *val)
         /* establish a new ldap tcp session if necessary */
 
 	if ( !ads->ldap.ld ) {
-		if ( (ads_s = ads_init( ads->server.realm, ads->server.workgroup, 
-			ads->server.ldap_server, ADS_SASL_PLAIN )) == NULL )
-		{
-			status = ADS_ERROR_NT(NT_STATUS_NO_MEMORY);
-			goto done;
+		/*
+		 * ADS_STRUCT may be being reused after a
+		 * DC lookup, so ads->ldap.ss may already have a
+		 * good address. If not, re-initialize the passed-in
+		 * ADS_STRUCT with the given server.XXXX parameters.
+		 *
+		 * Note that this doesn't depend on
+		 * ads->server.ldap_server != NULL,
+		 * as the case where ads->server.ldap_server==NULL and
+		 * ads->ldap.ss != zero_address is precisely the DC
+		 * lookup case where ads->ldap.ss was found by going
+		 * through ads_find_dc() again we want to avoid repeating.
+		 */
+		if (is_zero_addr(&ads->ldap.ss)) {
+			if ((ads_s = ads_init(ads->server.realm,
+						ads->server.workgroup,
+						ads->server.ldap_server,
+						ADS_SASL_PLAIN )) == NULL ) {
+				status = ADS_ERROR_NT(NT_STATUS_NO_MEMORY);
+				goto done;
+			}
 		}
 		ads_s->auth.flags = ADS_AUTH_ANON_BIND;
 		status = ads_connect( ads_s );
-- 
2.20.1

